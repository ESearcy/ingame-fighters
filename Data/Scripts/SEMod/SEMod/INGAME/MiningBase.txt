public Program()
{
Runtime.UpdateFrequency=UpdateFrequency.Update1;
shipComponents=new ShipComponents();
LocateAllParts();
SetupFleetListener();
log=new Logger(Me.CubeGrid,shipComponents);
communicationSystems=new CommunicationSystem(log,Me.CubeGrid,shipComponents);
navigationSystems=new BasicNavigationSystem(log,Me.CubeGrid,shipComponents);
factorySystems=new FactorySystem(log,Me.CubeGrid,shipComponents);
trackingSystems=new TrackingSystem(log,Me.CubeGrid,shipComponents,true);
weaponSystems=new WeaponSystem(log,Me.CubeGrid,shipComponents);
operatingOrder.AddLast(new TaskInfo(LocateAllParts));
operatingOrder.AddLast(new TaskInfo(NavigationCheck));
operatingOrder.AddLast(new TaskInfo(InternalSystemCheck));
operatingOrder.AddLast(new TaskInfo(ScanLocalArea));
operatingOrder.AddLast(new TaskInfo(UpdateTrackedTargets));
operatingOrder.AddLast(new TaskInfo(UpdateDisplays));
operatingOrder.AddLast(new TaskInfo(RecieveFleetMessages));
operatingOrder.AddLast(new TaskInfo(SendPendingMessages));
operatingOrder.AddLast(new TaskInfo(MaintainAltitude));
operatingOrder.AddLast(new TaskInfo(IssueOrders));
maxCameraRange=5000;
maxCameraAngle=80;
hoverHeight=400;
InitialBlockCount=shipComponents.AllBlocks.Count();
Runtime.UpdateFrequency=UpdateFrequency.Update1;
}
protected FactorySystem factorySystems;
protected BasicNavigationSystem navigationSystems;
List<DroneContext> drones=new List<DroneContext>();
public void RunProductionRoutine()
{
factorySystems.Update();
}
protected void Main(String argument,UpdateType updateType)
{
try
{
if (argument.Length==0)
{
Update();
}
else
{
IntrepretMessage(argument);
}
}
catch (Exception e)
{
log.Error(e.Message);
}
}
protected void UpdateAntenna()
{
foreach (var antenna in shipComponents.RadioAntennas)
{
antenna.CustomName="\nA: "+(int)trackingSystems.GetAltitude()+"\n" +
"S: "+(int)navigationSystems.GetSpeed();
}
}
private void RecieveFleetMessages()
{
var messages=RecieveMessages();
foreach (var mes in messages) {
var pm=communicationSystems.ParseMessage(mes);
if (ParsedMessage.MaxNumBounces < pm.NumBounces && pm.MessageType != MessageCode.PingEntity)
{
pm.NumBounces++;
communicationSystems.SendMessage(pm.ToString());
}
switch (pm.MessageType)
{
case MessageCode.Register:
RegisterDrone(pm);
break;
case MessageCode.Update:
UpdateDrone(pm);
break;
case MessageCode.PingEntity:
if (pm.Type.Trim().ToLower().Contains("planet"))
trackingSystems.UpdateSurfaceLocation(pm);
else
trackingSystems.UpdateTrackedEntity(pm);
break;
}
}
}
private void RegisterDrone(ParsedMessage pm)
{
var drone=drones.Where(x => x.Info.EntityId==pm.EntityId).FirstOrDefault();
if (drone==null)
{
drones.Add(new DroneContext(new DroneInfo(pm.EntityId,pm.Name,pm.Location,pm.Velocity),null));
UpdateDrone(pm);
}
communicationSystems.SendMessage(ParsedMessage.CreateConfirmationMessage(Me.CubeGrid.EntityId,pm.EntityId,pm.RequestID));
log.Debug("registered Drone");
UpdateDrone(pm);
}
private void IdentifyDroneType(DroneContext context)
{
bool scan=false,miner=false,combat=false;
if (context.Info.CameraCount > 0)
scan=true;
if ((context.Info.Guns+context.Info.Rockets) > 0)
combat=true;
if (context.Info.NumDrills > 0)
miner=true;
if (miner)
context.Info.Type=DroneType.Miner;
else if (combat)
context.Info.Type=DroneType.Combat;
else if (scan)
context.Info.Type=DroneType.Scan;
}
private DroneContext UpdateDrone(ParsedMessage pm)
{
var drone=drones.Where(x => x.Info.EntityId==pm.EntityId).FirstOrDefault();
if (drone==null)
{
drone=new DroneContext(new DroneInfo(pm.EntityId,pm.Name,pm.Location,pm.Velocity),null);
drones.Add(drone);
}
else
{
drone.Info.Update(pm.Name,pm.Location,pm.Velocity,pm.Docked,pm.CameraCount,pm.ShipSize,pm.DrillCount,pm.WeaponCount,pm.SensorCount,pm.ConnectorCount,pm.PercentCargo,pm.HP,pm.MaxStorage,pm.MergeCount,pm.GuneCount,pm.RocketCount,pm.ReactorCount,pm.BatteryCount,pm.CurrentPower,pm.MaxPower);
}
IdentifyDroneType(drone);
return drone;
}
public void IntrepretMessage(String argument)
{
if (argument==null)
return;
if (argument.StartsWith("FactoryShortcut:"))
{
factorySystems.ManualCommand(argument.Replace("FactoryShortcut:",""));
log.Debug("Engaged Manual Command "+argument);
return;
}
}
DateTime lastGlobalWakeupCall=DateTime.Now.AddMinutes(-10);
int droneOrderIndex=0;
public void ResendOrder(DroneOrder order)
{
if (order != null)
{
var time=(DateTime.Now-order.LastUpdated).TotalSeconds;
if (time>=10)
{
if (order.Ordertype==OrderType.Dock)
{
order.PrimaryLocation=order.Connector.GetPosition();
}
communicationSystems.TransmitOrder(order,Me.CubeGrid.EntityId);
log.Debug("Resending "+order.Ordertype+" order");
order.LastUpdated=DateTime.Now;
}
}
}
public void RunCommandBaseLogic(DroneContext droneInfo)
{
var drone=droneInfo.Info;
var order=droneInfo.Order;
var needOres=false;
var droneCargo=(drone.PercentCargo / drone.StorageMax)*100;
var batteryPercent=(int)((drone.CurrentPower/drone.MaxPower)*100);
if (order==null && drone.Docked)
{
log.Debug("docked and order null. Issuing standby order");
IssueStandbyOrder(droneInfo);
}
else if (order==null && !drone.Docked)
{
if (!IssueDockOrder(droneInfo))
{
log.Debug("undocked and order null. Dock Order failed,Issuing Standby Order.");
IssueStandbyOrder(droneInfo);
}
else
log.Debug("undocked and order null. Issuing Dock Order ");
}
else if (order != null && order.Ordertype==OrderType.Dock && drone.Docked)
{
log.Debug("Drone successfully docked-Issuing Standby Order");
IssueStandbyOrder(droneInfo);
}
else if (droneCargo > 75 && !drone.Docked && (order==null || order.Ordertype != OrderType.Dock))
{
var dockOrderIssued=IssueDockOrder(droneInfo);
if (!dockOrderIssued)
{
log.Debug("Cargo Full: unable to issue dock Order,Standby order issued");
IssueStandbyOrder(droneInfo);
}
else
log.Debug("Cargo Full: dock Order Issued");
}
else if (batteryPercent < 50 && !drone.Docked && (order==null || order.Ordertype != OrderType.Dock))
{
var dockOrderIssued=IssueDockOrder(droneInfo);
if (!dockOrderIssued)
{
log.Debug("Low Battery: unable to issue dock Order,Standby order issued");
IssueStandbyOrder(droneInfo);
}
else
log.Debug("Low Battery: dock Order Issued");
}
else if ((batteryPercent < 97 || droneCargo > 75) && drone.Docked)
{
if (order != null && order.Ordertype != OrderType.Standby)
{
log.Debug("Issuing Standby order while drone recharges/unloads");
IssueStandbyOrder(droneInfo);
}
}
else if (drone.Type==DroneType.Miner && MiningDroneLogic(droneInfo,drone,order)) ;
else if (drone.Type==DroneType.Combat && ScanDroneLogic(droneInfo,drone,order)) ;
else if (drone.Type==DroneType.Scan && ScanDroneLogic(droneInfo,drone,order)) ;
else if (order != null)
{
ResendOrder(order);
}
else
log.Error("No order issued-maybe something wrong with command logic");
}
private bool CombatDroneLogic(DroneContext droneInfo,DroneInfo drone,DroneOrder order)
{
return false;
}
List<DroneOrder> OngoingScanOrders=new List<DroneOrder>();
private bool ScanDroneLogic(DroneContext droneInfo,DroneInfo drone,DroneOrder order)
{
var awaitingOrders=(order != null && order.Ordertype==OrderType.Standby);
if (awaitingOrders)
{
IssueScanOrder(droneInfo);
}
else if (order != null && order.Ordertype==OrderType.Scan)
{
var droneDistance=Math.Abs((order.PrimaryLocation-drone.lastKnownPosition).Length());
if (droneDistance < 250 || (DateTime.Now-order.IssuedAt).TotalMinutes>=2)
{
order.PointOfIntrest.HasPendingOrder=false;
order.PointOfIntrest.Timestamp=DateTime.Now;
order.PointOfIntrest.Reached=true;
OngoingScanOrders.Remove(order);
trackingSystems.UpdateScanPoint(order.PointOfIntrest);
var nextScanPoint=trackingSystems.GetNearestScanPoint(Me.GetPosition(),600);
if (nextScanPoint != null)
{
droneInfo.Order=new DroneOrder(log,OrderType.Scan,communicationSystems.GetMsgSntCount(),0,drone.EntityId,nextScanPoint.Location,Vector3D.Zero,Vector3D.Zero);
droneInfo.Order.PointOfIntrest=nextScanPoint;
communicationSystems.TransmitOrder(droneInfo.Order,Me.CubeGrid.EntityId);
}
}
else
return false;
}
else
return false;
return true;
}
private bool MiningDroneLogic(DroneContext droneInfo,DroneInfo drone,DroneOrder order)
{
var awaitingOrders=order != null && order.Ordertype==OrderType.Standby && drone.Docked;
if (awaitingOrders)
{
IssueMiningOrder(droneInfo);
}
else if (order != null && order.Ordertype==OrderType.Standby && !drone.Docked)
{
IssueDockOrder(droneInfo);
}
else if (order != null && order.Ordertype==OrderType.Mine && !drone.Docked)
{
var directionV=navigationSystems.GetGravityDirection();
directionV.Normalize();
var target_endpoint=order.PrimaryLocation+(directionV*35);
var target_end_point_distance=(int)(drone.lastKnownPosition-target_endpoint).Length();
var target_between_start_and_end=(int)(order.PrimaryLocation-target_endpoint).Length();
if (target_end_point_distance<=5)
{
miningOrders.Remove(order);
order.PointOfIntrest.Mined=true;
IssueDockOrder(droneInfo);
}
else
return false;
}
else
return false;
return true;
}
public void IssueOrders()
{
try
{
if (droneOrderIndex>=drones.Count())
droneOrderIndex=0;
if ((DateTime.Now-lastGlobalWakeupCall).TotalMinutes>=10)
{
lastGlobalWakeupCall=DateTime.Now;
communicationSystems.SendAwakeningMessage();
log.Debug("sent awakening Message");
}
if (drones.Any())
{
var drone=drones[droneOrderIndex];
if (drone != null)
{
RunCommandBaseLogic(drone);
}
}
droneOrderIndex++;
}
catch (Exception e) { log.Error("IssueOrders "+e.Message+"\n"+e.StackTrace);}
log.UpdateFleetInformationScreens(drones,Me.CubeGrid);
}
private bool IssueDockOrder(DroneContext drone)
{
var unused=(drone.Info.NumDrills > 0) ?
shipComponents.Connectors.Where(x => x.Status != MyShipConnectorStatus.Connectable && x.Status != MyShipConnectorStatus.Connected && x.CustomName.Contains("#miner#") && !x.CustomName.Contains("#trash#")) :
shipComponents.Connectors.Where(x => x.Status != MyShipConnectorStatus.Connectable && x.Status != MyShipConnectorStatus.Connected && !x.CustomName.Contains("#miner#") && !x.CustomName.Contains("#trash#"));
var used=drones.Where(x => x.Order != null && x.Order.Connector != null).Select(x => x.Order.Connector);
var available=unused.Where(x => !used.Contains(x));
var usableConnector=available.FirstOrDefault();
if (usableConnector != null)
{
log.Debug("Issuing Dock Order");
var order=new DroneOrder(log,OrderType.Dock,communicationSystems.GetMsgSntCount(),usableConnector.EntityId,drone.Info.EntityId,usableConnector.GetPosition(),usableConnector.WorldMatrix.Forward,usableConnector.WorldMatrix.Up);
order.Connector=usableConnector;
communicationSystems.TransmitOrder(order,Me.CubeGrid.EntityId);
drone.Order=order;
return true;
}
return false;
}
private void IssueStandbyOrder(DroneContext drone)
{
log.Debug("Attampting Standby Order");
var order=new DroneOrder(log,OrderType.Standby,communicationSystems.GetMsgSntCount(),0,drone.Info.EntityId,Vector3D.Zero,Vector3D.Zero,Vector3D.Zero);
communicationSystems.TransmitOrder(order,Me.CubeGrid.EntityId);
drone.Order=order;
}
public void IssueAttackOrder(DroneContext drone)
{
var closestTargets=trackingSystems.getCombatTargets(Me.GetPosition());
if (closestTargets.Any())
{
var biggestTarget=closestTargets.OrderByDescending(x => x.Radius).FirstOrDefault();
if (biggestTarget != null)
{
log.Debug("Issuing Attack Order");
var order=new DroneOrder(log,OrderType.Attack,communicationSystems.GetMsgSntCount(),biggestTarget.EntityID,drone.Info.EntityId,biggestTarget.PointsOfInterest[0].Location,navigationSystems.GetGravityDirection(),biggestTarget.Location);
communicationSystems.TransmitOrder(order,Me.CubeGrid.EntityId);
drone.Order=order;
}
}
}
List<DroneOrder> miningOrders=new List<DroneOrder>();
protected void IssueMiningOrder(DroneContext droneinfo)
{
var existingOrder=miningOrders.Where(x => x.DroneId==droneinfo.Info.EntityId).ToList();
if (existingOrder.Any())
{
droneinfo.Order=existingOrder.First();
}
else
{
var drone=droneinfo.Info;
var miningTarget=trackingSystems.GetNextMiningSamplePoint(Me.GetPosition());
if (miningTarget != null)
{
miningTarget.HasPendingOrder=true;
var order=new DroneOrder(log,OrderType.Mine,communicationSystems.GetMsgSntCount(),0,drone.EntityId,miningTarget.Location,navigationSystems.GetGravityDirection(),Vector3D.Zero);
order.PointOfIntrest=miningTarget;
droneinfo.Order=order;
miningOrders.Add(order);
communicationSystems.TransmitOrder(order,Me.CubeGrid.EntityId);
}
}
}
private void IssueScanOrder(DroneContext droneInfo)
{
var existingOrder=OngoingScanOrders.Where(x => x.DroneId==droneInfo.Info.EntityId).ToList();
if (existingOrder.Any())
droneInfo.Order=existingOrder.First();
else
{
var drone=droneInfo.Info;
var miningTarget=trackingSystems.GetNearestScanPoint(Me.GetPosition(),600);
if (miningTarget != null)
{
miningTarget.HasPendingOrder=true;
var order=new DroneOrder(log,OrderType.Scan,communicationSystems.GetMsgSntCount(),0,drone.EntityId,miningTarget.Location,navigationSystems.GetGravityDirection(),Vector3D.Zero);
OngoingScanOrders.Add(order);
order.PointOfIntrest=miningTarget;
droneInfo.Order=order;
communicationSystems.TransmitOrder(order,Me.CubeGrid.EntityId);
log.Debug("scan order sent");
}
else
log.Debug("failed to get scan location");
}
}
protected void MaintainAltitude()
{
try
{
if (NearestPlanet != null)
{
if (navigationSystems.GetSpeed() > 10)
navigationSystems.SlowDown();
else if (drones.Any(x => x.Order !=null && ((DateTime.Now-x.Order.IssuedAt).TotalSeconds < 20 || !x.Info.Docked) && (x.Info.lastKnownPosition-Me.GetPosition()).Length() < 60))
navigationSystems.SlowDown();
else if (Math.Abs(hoverHeight-trackingSystems.GetAltitude()) > 5)
navigationSystems.MaintainAltitude(trackingSystems.GetAltitude(),hoverHeight,Math.Abs(trackingSystems.GetAltitude()-hoverHeight) / 2);
else
navigationSystems.SlowDown();
navigationSystems.AlignAgainstGravity();
}
else
log.Debug("No Planet");
}
catch (Exception e) { log.Error("MaintainAltitude "+e.StackTrace);}
}
private void NavigationCheck()
{
var ns=navigationSystems.IsOperational();
UpdateInfoKey("NavigationSystems",BoolToOnOff(ns)+"");
}
protected void UpdateDisplays()
{
try
{
UpdateInfoKey("Storage"," Mass: "+navigationSystems.RemoteControl.CalculateShipMass().PhysicalMass+" Max Mass: "+navigationSystems.GetMaxSupportedWeight());
UpdateInfoKey("Power: ","Current: "+CurPower+" Max: "+MaxPower);
if (NearestPlanet != null)
{
log.DisplayShipInfo(shipInfoKeys,"PlanetInfo:altitude: "+(int)trackingSystems.GetAltitude()+"m"+"Speed: "+(int)navigationSystems.GetSpeed()+"m/s");
log.UpdateRegionInfo(NearestPlanet.Regions,Me.CubeGrid);
}
else
log.DisplayShipInfo(shipInfoKeys," No Planet ");
}
catch (Exception e) { log.Error("UpdateDisplays "+e.Message);}
UpdateSystemScreens();
UpdateAntenna();
}

protected LinkedList<TaskInfo> operatingOrder=new LinkedList<TaskInfo>();
protected Logger log;
protected CommunicationSystem communicationSystems;
protected ShipComponents shipComponents;
protected TrackingSystem trackingSystems;
protected WeaponSystem weaponSystems;
protected DateTime startTime=DateTime.Now;
protected Dictionary<String,object> shipInfoKeys=new Dictionary<string,object>();
protected int sensorScansPerSecond=2;
protected int hoverHeight=900;
protected int lastOperationIndex=0;
protected DateTime lastReportTime=DateTime.Now;
protected long messagesRecieved=0;
public void SetupFleetListener()
{
IGC.RegisterBroadcastListener("fleet");
}
protected void LocateAllParts()
{
shipComponents.Sync(GridTerminalSystem,Me.CubeGrid);
}
protected void Update()
{
RunNextOperation();
}
public void SendPendingMessages()
{
var messages=communicationSystems.RetrievePendingMessages();
foreach (var message in messages)
TransmitMessage("fleet",message);
}
TaskResult lastTask=null;
TaskInfo lastTaskInfo=null;
protected void RunNextOperation()
{
if (lastTask != null)
{
lastTask.trueRuntme=Runtime.LastRunTimeMs;
lastTaskInfo.AddResult(lastTask);
}
if (lastOperationIndex==operatingOrder.Count())
lastOperationIndex=0;
TaskInfo info=operatingOrder.ElementAt(lastOperationIndex);
info.CallMethod();
lastTask=new TaskResult(Runtime.CurrentInstructionCount,Runtime.CurrentCallChainDepth);
lastTaskInfo=info;
lastOperationIndex++;
}
protected void InternalSystemCheck()
{
try
{
if(communicationSystems !=null)
UpdateInfoKey("communicationSystems",BoolToOnOff(communicationSystems.IsOperational())+"");
if (trackingSystems != null)
UpdateInfoKey("trackingSystems",BoolToOnOff(trackingSystems.IsOperational())+"");
if (weaponSystems != null)
UpdateInfoKey("weaponSystems",BoolToOnOff(weaponSystems.IsOperational())+"");
CalculatePower();
}
catch (Exception e) { log.Error("InternalSystemScan "+e.StackTrace);}
}
protected double CurPower=0;
protected double MaxPower=0;
protected void CalculatePower()
{
CurPower=0;
MaxPower=0;
foreach (var battery in shipComponents.Batteries)
{
CurPower += (double)battery.CurrentStoredPower;
MaxPower += (double)battery.MaxStoredPower;
}
}
Dictionary<String,String> all_refs=new Dictionary<string,string>();
public void UpdateSystemScreens()
{
try
{
all_refs.Clear();
if (trackingSystems != null)
foreach (var screen in trackingSystems.GetScreenInfo())
all_refs.Add(screen.Key,screen.Value);
Mass=(int)(GetCargoMass()+shipComponents.AllBlocks.Sum(x => x.Mass));
var controlBlock=shipComponents.ControlUnits.FirstOrDefault();
if (controlBlock != null)
{
var maxMass=(int)shipComponents.Thrusters.Where(x => x.WorldMatrix.Forward==controlBlock.WorldMatrix.Forward).Sum(x => x.MaxThrust) / (controlBlock.GetNaturalGravity().Length());
UpdateInfoKey("Weight Information"," Mass: "+Mass+"kgMaxMass: "+(int)maxMass+"kg");
}
foreach (var op in operatingOrder)
UpdateInfoKey(op.CallMethod.Method.Name+"",(
" true-runtime: "+op.GetTrueAverageExecutionTime() +
" CallCount: "+op.GetAverageCallCount() +
" CallDepth: "+op.GetAverageCallCount()+""));
log.DisplayLogs(shipComponents.TextPanels,all_refs);
}
catch (Exception e)
{
log.Error("UpdateSystemScreens "+e.StackTrace);
}
log.DisplayLogScreens();
}
protected int InitialBlockCount;
protected double GetHealth()
{
return shipComponents.AllBlocks.Count() / InitialBlockCount;
}
protected string BoolToOnOff(bool conv)
{
return conv ? "Online" : "Offline";
}
Dictionary<long,TrackedEntity> foundentities=new Dictionary<long,TrackedEntity>();
protected void ScanLocalArea()
{
try
{
foundentities.Clear();
ScanWithSensors(foundentities);
ScanWithCameras(foundentities);
if(trackingSystems != null)
{
foreach(var t in foundentities)
TrackTarget(t.Value);
}
}
catch (Exception e) { log.Error("SensorScan "+e.StackTrace);}
}
public void TrackTarget(TrackedEntity ent)
{
trackingSystems.TrackEntity(ent,true);
}
int sensorindex=0;
protected void ScanWithSensors(Dictionary<long,TrackedEntity> foundentities)
{
if (sensorindex==shipComponents.Sensors.Count())
sensorindex=0;
var miliseconds=(DateTime.Now-lastReportTime).TotalMilliseconds;
if (miliseconds>=1000 / sensorScansPerSecond && sensorindex < shipComponents.Sensors.Count())
{
lastReportTime=DateTime.Now;
var sensor=shipComponents.Sensors[sensorindex];
sensor.DetectEnemy=true;
sensor.DetectPlayers=true;
sensor.DetectLargeShips=true;
sensor.DetectSmallShips=true;
sensor.DetectOwner=false;
sensor.DetectStations=true;
sensor.DetectAsteroids=true;
var ent=sensor.LastDetectedEntity;
if (ent.EntityId != 0)
{
if (!foundentities.Keys.Contains(ent.EntityId))
{
var t=new TrackedEntity(
ent.Position
,ent.Velocity
,ent.Position
,ent.EntityId
,ent.Name
,0
,ent.Relationship
,ent.Position
,ent.Type.ToString()
,log);;
foundentities.Add(ent.EntityId,t);
}
}
}
sensorindex++;
}
protected int pitch=0;
protected int yaw=0;
protected int range=0;
protected int maxCameraRange=2000;
protected int maxCameraAngle=90;
int cameraIndex=0;
protected void ScanWithCameras(Dictionary<long,TrackedEntity> foundentities)
{
if (cameraIndex==shipComponents.Cameras.Count())
cameraIndex=0;
var camera=shipComponents.Cameras[cameraIndex];
var maxAngle=maxCameraAngle;
var maxRange=maxCameraRange;
if (!camera.EnableRaycast)
camera.EnableRaycast=true;
var timeToScan=camera.TimeUntilScan(range);
if (timeToScan<=0 && cameraIndex < shipComponents.Cameras.Count())
{
pitch -= 5;
if (pitch<=-maxAngle)
{
pitch=pitch*-1;
yaw -= 5;
}
if (yaw<=-maxAngle)
{
yaw=yaw*-1;
}
if (range<=1)
{
range=maxCameraRange;
}
var ent=camera.Raycast(range,pitch,yaw);
if (ent.EntityId != 0)
{
if (!foundentities.Keys.Contains(ent.EntityId))
{
var t=new TrackedEntity(ent.Position,ent.Velocity,ent.HitPosition.Value,ent.EntityId,ent.Name,(int)Math.Abs((ent.BoundingBox.Min-ent.BoundingBox.Max).Length()),ent.Relationship,ent.HitPosition.Value,ent.Type.ToString(),log);
foundentities.Add(ent.EntityId,t);
}
}
}
cameraIndex++;
}
private void TransmitMessage(String destination,String message)
{
IGC.SendBroadcastMessage(destination,message,TransmissionDistance.TransmissionDistanceMax);
}
protected void ParseMessage(string argument,bool selfCalled=false)
{
try
{
if (argument==null)
return;
var pm=communicationSystems.ParseMessage(argument);
if (ParsedMessage.MaxNumBounces < pm.NumBounces && !selfCalled && pm.MessageType != MessageCode.PingEntity)
{
pm.NumBounces++;
communicationSystems.SendMessage(pm.ToString());
}
}
catch (Exception e) { log.Error(e.Message);}
}
internal PlanetaryData NearestPlanet=null;
protected void UpdateTrackedTargets()
{
try
{
trackingSystems.Update();
NearestPlanet=trackingSystems.GetNearestPlanet();
}
catch (Exception e) { log.Error("UpdateTrackedTargets "+e.Message);}
}
protected void UpdateInfoKey(string name,string value)
{
if (shipInfoKeys.Keys.Contains(name))
shipInfoKeys.Remove(name);
shipInfoKeys.Add(name,value);
}
protected double GetCargoMass()
{
return 0;
}
protected int Mass=0;
List<String> incomingMessages=new List<String>();
public List<String> RecieveMessages()
{
List<IMyBroadcastListener> listeners=new List<IMyBroadcastListener>();
IGC.GetBroadcastListeners(listeners);
incomingMessages.Clear();
if (listeners[0].HasPendingMessage)
{
MyIGCMessage message=new MyIGCMessage();
message=listeners[0].AcceptMessage();
if (message.Data != null)
{
string messagetext=message.Data.ToString();
string messagetag=message.Tag;
long sender=message.Source;
incomingMessages.Add(messagetext);
}
}
return incomingMessages;
}
public class Factory
{
Logger L;
List<IMyShipWelder> welders=new List<IMyShipWelder>();
List<IMyProjector> projectors=new List<IMyProjector>();
List<IMyExtendedPistonBase> pistons=new List<IMyExtendedPistonBase>();
List<IMyAirtightHangarDoor> doors=new List<IMyAirtightHangarDoor>();
List<IMyShipMergeBlock> merges=new List<IMyShipMergeBlock>();
public FactoryState currentState=FactoryState.Unknown;
const float rotationVelocity=3f;
public Factory(IMyBlockGroup group,Logger log)
{
L=log;
ConfigureComponents(group);
FindCurrentState();
L.Debug("Group Parts");
}
public void ConfigureComponents(IMyBlockGroup group)
{
welders.Clear();
projectors.Clear();
pistons.Clear();
doors.Clear();
merges.Clear();
group.GetBlocksOfType(welders);
group.GetBlocksOfType(projectors);
group.GetBlocksOfType(pistons);
group.GetBlocksOfType(doors);
group.GetBlocksOfType(merges);
}
public void UpdateFactoryState()
{
var pistonSpeed=pistons.Average(x => x.Velocity);
var pistonExtended=pistons.Any(x => x.CurrentPosition==x.MaxLimit);
var pistonRetracted=pistons.All(x => x.CurrentPosition==0);
var constructionPartial=merges.Any(x => x.IsConnected);
var weldersOnline=welders.Any(x => x.Enabled);
var sevenSecondsPassed=(DateTime.Now-LaunchStartTime).TotalSeconds > 7;
switch (currentState)
{
case FactoryState.Unknown:
FindCurrentState();
break;
case FactoryState.Starting:
L.Debug(pistonExtended+" Extended");
if (pistonExtended)
currentState=FactoryState.ReadyToBuild;
break;
case FactoryState.ReadyToBuild:
Build();
currentState=FactoryState.Building;
break;
case FactoryState.Building:
if(pistonRetracted && constructionPartial)
currentState=FactoryState.ReadyToLaunch;
break;
case FactoryState.ReadyToLaunch:
break;
case FactoryState.Launching:
if (sevenSecondsPassed)
currentState=FactoryState.Complete;
break;
case FactoryState.Complete:
break;
}
}
private DateTime LaunchStartTime=DateTime.Now;
String bPName="#test#";
public void Start(String bpName)
{
bPName=bpName;
currentState=FactoryState.Starting;
L.Debug("Extending pistons");
Extend();
}
public void Launch()
{
currentState=FactoryState.Launching;
LaunchStartTime=DateTime.Now;
Release();
}
private void FindCurrentState()
{
var pistonSpeed=pistons.Average(x=>x.Velocity);
var pistonExtended=pistons.Any(x=>x.CurrentPosition==x.MaxLimit);
var pistonRetracted=pistons.All(x => x.CurrentPosition==0);
var constructionPartial=merges.Any(x=>x.IsConnected);
var weldersOnline=welders.Any(x=>x.Enabled);
var sevenSecondsPassed=(DateTime.Now-LaunchStartTime).TotalSeconds>7;
if(pistonSpeed > 0)
{
if (pistonExtended)
{
currentState=FactoryState.ReadyToBuild;
}
else
currentState=FactoryState.Starting;
}
else
{
if (pistonRetracted)
{
if (constructionPartial)
currentState=FactoryState.ReadyToLaunch;
else
currentState=FactoryState.Complete;
}
else
currentState=FactoryState.Building;
}
}
public IMyProjector GetPrimaryProjector()
{
var w=TryGetProjectorWithNameContaining(bPName);
if (w != null)
{
w.Enabled=true;
return w;
}
return null;
}
private void Build()
{
var w=TryGetProjectorWithNameContaining(bPName);
if (w != null)
{
w.Enabled=true;
foreach (var merge in merges)
merge.GetActionWithName("OnOff_On").Apply(merge);
foreach (var piston in pistons)
piston.SetValue<float>("Velocity",-1);
foreach (var welder in welders)
welder.GetActionWithName("OnOff_On").Apply(welder);
}
}
private IMyProjector TryGetProjectorWithNameContaining(String name)
{
foreach (var projector in projectors)
if (projector.CustomName.Contains(name))
return projector;
return null;
}
internal bool IsOperational()
{
return welders.Any() && projectors.Any() && pistons.Any() && merges.Any();
}
public string CompCounts()
{
return "W:"+welders.Count()+ " PR:"+projectors.Count() +" PI:"+pistons.Count() +" M:"+merges.Count();;
}
public void Extend()
{
foreach (var piston in pistons)
piston.SetValue<float>("Velocity",1);
foreach (var welder in welders)
welder.GetActionWithName("OnOff_Off").Apply(welder);
}
public void Release()
{
foreach (var welder in welders)
welder.GetActionWithName("OnOff_Off").Apply(welder);
foreach (var merge in merges)
{
merge.GetActionWithName("OnOff_Off").Apply(merge);
merge.Enabled=false;
}
}
}
public class FactorySystem
{
Logger L;
public Dictionary<String,Factory> Factories=new Dictionary<String,Factory>();
ShipComponents shipComponents;
IMyCubeGrid primaryGrid;
const float rotationVelocity=3f;
public FactorySystem(Logger log,IMyCubeGrid grid,ShipComponents components)
{
L=log;
shipComponents=components;
primaryGrid=grid;
}
public bool IsOperational()
{
return Factories.Any();
}
public void Update()
{
foreach (var group in shipComponents.Groups.Where(x=>x.Name.ToLower().Contains("#factory#")))
{
if (!Factories.Keys.Contains(group.Name))
{
Factories.Add(group.Name,new Factory(group,L));
}
else
{
Factories[group.Name].ConfigureComponents(group);
}
}
UpdateFactoryStates();
}
DateTime lastUpdate=DateTime.Now;
public void UpdateFactoryStates()
{
if ((DateTime.Now-lastUpdate).TotalSeconds > 1)
{
foreach (var factory in Factories)
factory.Value.UpdateFactoryState();
lastUpdate=DateTime.Now;
}
}
private void Launch(String factoryName)
{
if (Factories.Keys.Contains(factoryName))
{
Factories[factoryName].Launch();
L.Debug("Launch successful");
}
}
public void Build(String factoryName,String bpName)
{
L.Debug(Factories.Keys.First());
if (Factories.Keys.Contains(factoryName))
{
Factories[factoryName].Start(bpName);
L.Debug("build successful");
}
}
internal void ManualCommand(string v)
{
if (v.Contains("Launch:"))
{
L.Debug("launching");
Launch(v.Replace("Launch:",""));
}
if (v.Contains("Build:"))
{
var factoryName=v.Replace("Build:","").Split(':')[0];
var bpName=v.Replace("Build:","").Split(':')[1];
L.Debug("building " +factoryName+""+bpName);
Build(factoryName,bpName);
}
}
}
public class DroneContext
{
public DroneInfo Info;
public DroneOrder Order;
public DroneContext(DroneInfo info,DroneOrder o)
{
Order=o;
Info=info;
}
}
public class DroneOrder
{
public OrderType Ordertype=OrderType.Unknown;
public long DroneId;
public double RequestId;
public bool Initalized=false;
public Vector3D PrimaryLocation;
public Vector3D DirectionalVectorOne;
public Vector3D ThirdLocation;
public DateTime IssuedAt;
public DateTime LastUpdated;
public long TargetEntityID;
public bool Confirmed=false;
public PointOfInterest PointOfIntrest;
public Vector3D Destination;
internal IMyShipConnector Connector;
Logger log;
public DroneOrder(Logger l, OrderType type,double requestID,long targetEntityId,long DroneID,Vector3D primaryLocation,Vector3D vectortwo,Vector3D thirdLocation)
{
log=l;
TargetEntityID=targetEntityId;
RequestId=requestID;
IssuedAt=DateTime.Now;
LastUpdated=IssuedAt;
DroneId=DroneID;
Ordertype=type;
PrimaryLocation=primaryLocation;
DirectionalVectorOne=vectortwo;
ThirdLocation= thirdLocation;
DirectionalVectorOne.Normalize();
ThirdLocation.Normalize();
Initalize();
DockRouteIndex=dockroute.Count()-1;
}
internal void Initalize()
{
switch (Ordertype)
{
case OrderType.Scan:
Destination=PrimaryLocation+(-DirectionalVectorOne*500);
break;
case OrderType.Attack:
Destination=PrimaryLocation;
break;
case OrderType.Dock:
UpdateDockingCoords();
break;
case OrderType.Mine:
UpdateMiningCoords();
break;
}
}
int dockingDistance=60;
public int DockRouteIndex=39;
public List<Vector3D> dockroute=new List<Vector3D>();
internal void UpdateDockingCoords()
{
dockroute.Clear();
for (int i= 1;i < dockingDistance;i++)
{
dockroute.Add(PrimaryLocation+(DirectionalVectorOne*i));
}
}
int miningDepth=20;
public int MiningIndex=0;
internal void UpdateMiningCoords()
{
dockroute.Clear();
dockroute.Add(PrimaryLocation-(DirectionalVectorOne*10));
dockroute.Add(PrimaryLocation-(DirectionalVectorOne*5));
for (double i=1;i < miningDepth;i+=.2)
{
dockroute.Add(PrimaryLocation+(DirectionalVectorOne*i));
}
}
}
public class PlanetaryData
{
public Vector3D PlanetCenter;
public Dictionary<long,Region> Regions=new Dictionary<long,Region>();
public DateTime LastUpdated;
private Logger log;
public PlanetaryData(Logger log,Vector3D planetCenter,Region region,Vector3D detectorLocation)
{
this.log=log;
PlanetCenter=planetCenter;
LastUpdated=DateTime.Now;
UpdatePlanetaryData(region,detectorLocation);
}
public bool UpdatePlanetaryData(Region region,Vector3D detectorLocation)
{
bool addedLocation=false;
LastUpdated=DateTime.Now;
var existingRegion=Regions.Where(x => x.Key==region.EntityId).Select(x=> x.Value).FirstOrDefault();
if (existingRegion!=null)
{
addedLocation=existingRegion.UpdateRegion(region,detectorLocation);
}
else
{
log.Debug("Logging New Region");
addedLocation=true;
Regions.Add(region.EntityId,region);
}
return addedLocation;
}
public Vector3D GetNearestPoint(Vector3D gridLocation)
{
var closestRegions=Regions.OrderBy(x => (x.Value.surfaceCenter-gridLocation).Length()).Take(5)
.OrderBy(x => (x.Value.GetNearestPoint(gridLocation)-gridLocation).Length());
if (closestRegions.Any())
return closestRegions.First().Value.GetNearestPoint(gridLocation);
else return new Vector3D();
}
}
public class Region
{
public long EntityId;
public List<PointOfInterest> PointsOfInterest=new List<PointOfInterest>();
public List<PointOfInterest> nearestPoints=new List<PointOfInterest>();
public DateTime LastUpdated;
public Vector3D PlanetCenter;
public Vector3D surfaceCenter;
long timesScanned=0;
long minDistBetweenPOI;
int maxSavedPoints;
bool iscmd;
Logger log;
public double GetScanDensity()
{
var density=timesScanned / PointsOfInterest.Count();
return density;
}
public bool UpdateRegion(Region region,Vector3D detectorLocation)
{
bool updatedLocation=false;
timesScanned++;
LastUpdated=DateTime.Now;
var location=region.PointsOfInterest[0];
updatedLocation=UpdatePoints(location);
return updatedLocation;
}
public Region(long EntityId,Vector3D planetLocation,PointOfInterest point,bool iscommand,Vector3D myship_loc,Logger log)
{
this.log=log;
iscmd=iscommand;
minDistBetweenPOI=iscmd ? 150 : 30;
maxSavedPoints=iscmd ? 50 : 15;
this.EntityId=EntityId;
LastUpdated=DateTime.Now;
lastLocation=myship_loc;
PlanetCenter=planetLocation;
UpdatePoints(point);
}
public bool UpdatePoints(PointOfInterest newpoint)
{
bool added=false;
var tooclosetootherpoints=PointsOfInterest.Any(eachpoint => Math.Abs((eachpoint.Location-newpoint.Location).Length()) < minDistBetweenPOI);
if (!tooclosetootherpoints)
{
if (PointsOfInterest.Count < maxSavedPoints)
{
added=true;
PointsOfInterest.Add(newpoint);
}
else if (PointsOfInterest.Count+1>=maxSavedPoints)
{
PointsOfInterest.Add(newpoint);
PointsOfInterest.RemoveAt(0);
added=true;
}
else
log.Debug("Failed to save location ");
if (added)
{
if (PointsOfInterest.Count()==1)
surfaceCenter=newpoint.Location;
else
{
var mtplr=PointsOfInterest.Count();
var loc=newpoint.Location;
var x=surfaceCenter.X+loc.X*mtplr;
var y=surfaceCenter.Y+loc.Y*mtplr;
var z=surfaceCenter.Z+loc.Z*mtplr;
surfaceCenter=new Vector3D(x / mtplr,y / mtplr,z / mtplr);
}
UpdateNearestPoints(newpoint);
}
}
return added;
}
List<PointOfInterest> furtherPoints= new List<PointOfInterest>();
private void UpdateNearestPoints(PointOfInterest newpoint) {
var dis=Math.Abs((newpoint.Location-lastLocation).Length());
if (nearestPoints.Count==0)
nearestPoints.Add(newpoint);
else if (nearestPoints.Count < maxSavedPoints / 2)
{
nearestPoints.Add(newpoint);
}
else if (nearestPoints.Count>=maxSavedPoints / 2)
{
furtherPoints=nearestPoints.Where(x => (x.Location-lastLocation).Length() > dis).ToList();
if (furtherPoints.Any())
{
nearestPoints.Add(newpoint);
nearestPoints.Remove(furtherPoints.First());
}
furtherPoints.Clear();
}
}
Vector3D lastLocation;
internal Vector3D GetNearestPoint(Vector3D shipLoc)
{
lastLocation=shipLoc;
nearestPoints=nearestPoints.OrderBy(x => (shipLoc-x.Location).Length()).ToList();
return nearestPoints.FirstOrDefault().Location;
}
internal PointOfInterest GetNearestSurveyPoint(Vector3D vector3D)
{
return PointsOfInterest.Where(x => !x.HasPendingOrder && (DateTime.Now-x.Timestamp).TotalMinutes > 30).OrderBy(x => Math.Abs((vector3D-x.Location).Length())).FirstOrDefault();
}
internal double GetPercentReached()
{
return PointsOfInterest.Where(x => x.Reached).Count() / PointsOfInterest.Count()*100;
}
}
public class BasicNavigationSystem
{
internal IMyCubeGrid _grid;
public IMyRemoteControl RemoteControl;
internal IMyShipConnector _shipConnector;
internal Logger log;
internal ShipComponents components;
internal Base6Directions.Direction _shipUp=0;
internal Base6Directions.Direction _shipLeft=0;
internal Base6Directions.Direction _shipForward=0;
internal Base6Directions.Direction _shipDown=0;
internal Base6Directions.Direction _shipRight=0;
internal Base6Directions.Direction _shipBackward=0;
internal double _degreesToVectorYaw=0;
internal double _degreesToVectorPitch=0;
internal float _alignSpeedMod=.02f;
internal float _rollSpeed=2f;
internal List<GyroOverride> _gyroOverrides=new List<GyroOverride>();
public BasicNavigationSystem(Logger LOG,IMyCubeGrid entity,ShipComponents components)
{
this.log=LOG;
this.components=components;
RemoteControl=this.components.ControlUnits.FirstOrDefault();
_grid=entity;
SetShipOrientation();
}
public double MaxSupportedWeight=0;
public int GetMaxSupportedWeight() {
MaxSupportedWeight=0;
foreach (var thruster in components.Thrusters)
{
var currentThrust=thruster.CurrentThrust;
var maxPossibleThrust=thruster.MaxThrust;
var thrusterVector=thruster.WorldMatrix.Forward;
var gravity=RemoteControl.GetNaturalGravity();
var Upward=Math.Abs(AngleBetween(gravity,thrusterVector,true)) < 45;
if(Upward)
MaxSupportedWeight += maxPossibleThrust;
}
return (int)MaxSupportedWeight;
}
public void SetShipOrientation()
{
if (RemoteControl != null)
{
_shipUp=RemoteControl.Orientation.Up;
_shipLeft=RemoteControl.Orientation.Left;
_shipForward=RemoteControl.Orientation.Forward;
}
}
internal void MaintainAltitude(double altitude,double minAltitude,double maxSpeed)
{
var gravityDir=RemoteControl.GetNaturalGravity();
gravityDir.Normalize();
var HoverLocation=RemoteControl.GetPosition()-gravityDir*(minAltitude-altitude);
Vector3D direction=RemoteControl.GetPosition()-HoverLocation;
direction.Normalize();
var difference=minAltitude-altitude;
if (GetSpeed() < maxSpeed)
ThrustInDirection((direction*2));
else
SlowDown();
}
float RollSetting=.4f;
public double AlignUp(Vector3D position)
{
var currentAlign=RemoteControl.WorldMatrix.Up;
var anglebetween=AngleBetween(currentAlign,RemoteControl.GetPosition()-position,true);
var anglefromleft=AngleBetween(RemoteControl.WorldMatrix.Left,RemoteControl.GetPosition()-position,true);
var anglefromright=AngleBetween(RemoteControl.WorldMatrix.Right,RemoteControl.GetPosition()-position,true);
TurnOffGyros(true);
var rollSpeed=anglebetween / 10 > .5 ? RollSetting : anglebetween / 10;
var worked=Roll(anglefromleft < anglefromright ? (float)-(rollSpeed) : anglefromleft > anglefromright ? (float)(rollSpeed) : 0);
log.Debug("Angle Between "+anglebetween+" : "+worked+" : "+anglefromleft+" : "+anglefromright);
return anglebetween;
}
internal Vector3D GetGravityDirection()
{
return RemoteControl.GetNaturalGravity();
}
public bool ThrustInDirection(Vector3D desiredVector,bool blockUpDownGravityMovement=false,bool disableIsAlreadyRunning=true)
{
var thrusted=false;
if (!RemoteControl.DampenersOverride)
RemoteControl.DampenersOverride=true;
foreach (var thruster in components.Thrusters)
{
var currentThrust=thruster.CurrentThrust;
var maxPossibleThrust=thruster.MaxThrust;
var desiredThrust=(currentThrust)+(maxPossibleThrust);
if (desiredThrust > maxPossibleThrust) desiredThrust=maxPossibleThrust;
thruster.GetActionWithName("OnOff_On").Apply(thruster);
var thrusterVector=thruster.WorldMatrix.Forward;
double angle=Math.Abs(AngleBetween(thrusterVector,desiredVector,true));
var gravity=RemoteControl.GetNaturalGravity();
var Downward=Math.Abs(AngleBetween(-gravity,thrusterVector,true)) < 80;
var Upward=Math.Abs(AngleBetween(gravity,thrusterVector,true)) < 80;
if (angle<=85)
{
if (blockUpDownGravityMovement && (!Downward && !Upward))
{
thruster.SetValueFloat("Override",(float)(desiredThrust));
}
else if (!Downward)
{
thruster.SetValueFloat("Override",(float)(desiredThrust));
}
else if (Downward && !blockUpDownGravityMovement)
{
thruster.SetValueFloat("Override",desiredThrust / 4);
}
thrusted=true;
}
else if (disableIsAlreadyRunning)
thruster.SetValueFloat("Override",0);
}
return thrusted;
}
public static double AngleBetween(Vector3D u,Vector3D v,bool returndegrees)
{
double toppart=0;
toppart += u.X*v.X;
toppart += u.Y*v.Y;
toppart += u.Z*v.Z;
double u2=0;//u squared
double v2=0;//v squared
u2 += u.X*u.X;
v2 += v.X*v.X;
u2 += u.Y*u.Y;
v2 += v.Y*v.Y;
u2 += u.Z*u.Z;
v2 += v.Z*v.Z;
double bottompart=0;
bottompart=Math.Sqrt(u2*v2);
double rtnval=Math.Acos(toppart / bottompart);
if (returndegrees) rtnval *= 360.0 / (2*Math.PI);
return rtnval;
}
public bool Roll(float angle)
{
bool worked=false;
foreach (var gyro in _gyroOverrides)
{
try
{
log.Debug("rolling "+angle);
gyro.EnableOverride();
gyro.OverrideRoll(angle);
worked=true;
}
catch (Exception e)
{
log.Error(e.ToString());
}
}
return worked;
}
public bool IsOperational()
{
int numGyros=GetWorkingGyroCount();
int numThrusters=GetWorkingThrusterCount();
int numThrustDirections=GetNumberOfValidThrusterDirections();
bool hasSufficientGyros=components.Gyros.Count > 0 && _gyroOverrides.Count > 0;
bool operational=(numGyros > 0 && numThrusters > 0);
var atleasthalfWorking=numThrusters>=components.Thrusters.Count() / 2;
return operational && atleasthalfWorking && hasSufficientGyros;
}
private void ResetGyros()
{
_gyroOverrides.Clear();
foreach (var gyro in components.Gyros)
{
_gyroOverrides.Add(new GyroOverride(gyro,_shipForward,_shipUp,_shipLeft,_shipDown,_shipRight,_shipBackward,log));
}
}
public int GetWorkingThrusterCount()
{
return components.Thrusters.Count;
}
int lastGyroCount=0;
public int GetWorkingGyroCount()
{
if (lastGyroCount != components.Gyros.Count)
{
ResetGyros();
lastGyroCount=components.Gyros.Count;
}
return components.Gyros.Count;
}
private int GetNumberOfValidThrusterDirections()
{
int up=0;
int down=0;
int left=0;
int right=0;
int forward=0;
int backward=0;
for (int i=0;i < components.Thrusters.Count(x => x.IsWorking);i++)
{
Base6Directions.Direction thrusterForward=components.Thrusters[i].Orientation.TransformDirectionInverse(_shipForward);
if (thrusterForward==Base6Directions.Direction.Up)
{
up++;
}
else if (thrusterForward==Base6Directions.Direction.Down)
{
down++;
}
else if (thrusterForward==Base6Directions.Direction.Left)
{
left++;
}
else if (thrusterForward==Base6Directions.Direction.Right)
{
right++;
}
else if (thrusterForward==Base6Directions.Direction.Forward)
{
forward++;
}
else if (thrusterForward==Base6Directions.Direction.Backward)
{
backward++;
}
}
int sum=(up > 0 ? 1 : 0)
+(down > 0 ? 1 : 0)
+(left > 0 ? 1 : 0)
+(right > 0 ? 1 : 0)
+(forward > 0 ? 1 : 0)
+(backward > 0 ? 1 : 0)
;
return sum;
}
public void StopRoll()
{
foreach (var gyro in _gyroOverrides)
{
try
{
gyro.DisableOverride();
gyro.OverrideRoll(0);// GyroSetFloatValue(_gyroRoll[i],0,gyro);
}
catch (Exception e)
{
log.Error(e.ToString());
}
}
}
public void StopSpin()
{
TurnOffGyros(false);
}
public void SlowDown()
{
foreach (var thru in components.Thrusters)
{
if (thru.ThrustOverride > 0)
thru.ThrustOverride=0;
}
RemoteControl.DampenersOverride=true;
RemoteControl.IsMainCockpit=true;
}
public double GetSpeed()
{
if (RemoteControl != null)
{
return RemoteControl.GetShipSpeed();
}
else return 0;
}
public void AlignAgainstGravity()
{
var align=RemoteControl.GetPosition()+(RemoteControl.GetNaturalGravity()*100);
AlignTo(align);
}
public double AlignTo(Vector3D position)
{
TurnOffGyros(true);
PointToVector(position,0.00);
var angoff=(_degreesToVectorPitch+_degreesToVectorYaw);
return Math.Abs(angoff);
}
internal void TurnOffGyros(bool off)
{
for (int i=0;i < components.Gyros.Count;i++)
{
if ((components.Gyros[i]).GyroOverride != off)
{
TerminalBlockExtentions.ApplyAction(components.Gyros[i],"Override");
}
}
}
internal void DegreesToVector(Vector3D TV)
{
IMyTerminalBlock guideblock=RemoteControl;
if (guideblock != null)
{
var Origin=guideblock.GetPosition();
var Up=guideblock.WorldMatrix.Up;
var Forward=guideblock.WorldMatrix.Forward;
var Right=guideblock.WorldMatrix.Right;
Vector3D OV=Origin;//Get positions of reference blocks.
Vector3D FV=Origin+Forward;
Vector3D UV=Origin+Up;
Vector3D RV=Origin+Right;
double TVOV=(OV-TV).Length();
double TVFV=(FV-TV).Length();
double TVUV=(UV-TV).Length();
double TVRV=(RV-TV).Length();
double OVUV=(UV-OV).Length();
double OVRV=(RV-OV).Length();
double ThetaP=Math.Acos((TVUV*TVUV-OVUV*OVUV-TVOV*TVOV) / (-2*OVUV*TVOV));
double ThetaY=Math.Acos((TVRV*TVRV-OVRV*OVRV-TVOV*TVOV) / (-2*OVRV*TVOV));
double RPitch=90-(ThetaP*180 / Math.PI);//Convert from radians to degrees.
double RYaw=90-(ThetaY*180 / Math.PI);
if (TVOV < TVFV) RPitch=180-RPitch;//Normalize angles to -180 to 180 degrees.
if (RPitch > 180) RPitch=-1*(360-RPitch);
if (TVOV < TVFV) RYaw=180-RYaw;
if (RYaw > 180) RYaw=-1*(360-RYaw);
_degreesToVectorYaw=RYaw;
_degreesToVectorPitch=RPitch;
}
}
public void PointToVector(Vector3D TV,double precision,bool wobble=false)
{
DegreesToVector(TV);
if (wobble)
{
if (_degreesToVectorPitch > 0)
_degreesToVectorPitch += .001;
else
_degreesToVectorPitch += -.001;
if (_degreesToVectorYaw > 0)
_degreesToVectorYaw += .001;
else
_degreesToVectorYaw += -.001;
}
foreach (var gyro in _gyroOverrides)
{
try
{
gyro.TurnOn();
if (Math.Abs(_degreesToVectorYaw) > precision)
{
gyro.OverrideYaw((float)_degreesToVectorYaw*_alignSpeedMod);
}
else
{
gyro.OverrideYaw(0);
}
if (Math.Abs(_degreesToVectorPitch) > precision)
{
gyro.OverridePitch((float)_degreesToVectorPitch*_alignSpeedMod);
}
else
{
gyro.OverridePitch(0);
}
}
catch (Exception e)
{
log.Error(e.ToString());
}
}
}
public class GyroOverride
{
Base6Directions.Direction up=Base6Directions.Direction.Up;
Base6Directions.Direction down=Base6Directions.Direction.Down;
Base6Directions.Direction left=Base6Directions.Direction.Left;
Base6Directions.Direction right=Base6Directions.Direction.Right;
Base6Directions.Direction forward=Base6Directions.Direction.Forward;
Base6Directions.Direction backward=Base6Directions.Direction.Backward;
public IMyGyro gyro;
String Pitch="Pitch";
String Yaw="Yaw";
String Roll="Roll";
int pitchdir=1;
int yawdir=1;
int rolldir=1;
Logger LOG;
public void DisableOverride()
{
if (gyro.GyroOverride)
{
gyro.GetActionWithName("Override").Apply(gyro);
}
}
public void EnableOverride()
{
if (!gyro.GyroOverride)
{
gyro.GetActionWithName("Override").Apply(gyro);
}
}
public void TurnOff()
{
gyro.GetActionWithName("OnOff_Off").Apply(gyro);
}
public void TurnOn()
{
gyro.GetActionWithName("OnOff_On").Apply(gyro);
}
public void OverridePitch(float value)
{
GyroSetFloatValue(Pitch,pitchdir*value);
}
public void OverrideRoll(float value)
{
GyroSetFloatValue(Roll,rolldir*value);
}
public void OverrideYaw(float value)
{
GyroSetFloatValue(Yaw,yawdir*value);
}
private void GyroSetFloatValue(String dir,float value)
{
if (dir=="Yaw")
{
gyro.Yaw=value;
}
else if (dir=="Pitch")
{
gyro.Pitch=value;
}
else if (dir=="Roll")
{
gyro.Roll=value;
}
}
public GyroOverride(IMyGyro _gyro,Base6Directions.Direction _shipForward,Base6Directions.Direction _shipUp,Base6Directions.Direction _shipLeft,Base6Directions.Direction _shipDown,Base6Directions.Direction _shipRight,Base6Directions.Direction _shipBackward,Logger logger)
{
LOG=logger;
Base6Directions.Direction gyroup=_gyro.Orientation.TransformDirectionInverse(_shipUp);
Base6Directions.Direction gyroleft=_gyro.Orientation.TransformDirectionInverse(_shipLeft);
Base6Directions.Direction gyroforward=_gyro.Orientation.TransformDirectionInverse(_shipForward);
this.gyro=_gyro;
if (gyroup==up)
{
if (gyroforward==left)
{
Pitch="Roll";rolldir=1;
Roll="Pitch";pitchdir=1;
Yaw="Yaw";yawdir=1;
}
if (gyroforward==right)
{
Pitch="Roll";rolldir=1;
Roll="Pitch";pitchdir=-1;
Yaw="Yaw";yawdir=1;
}
if (gyroforward==forward)
{
Pitch="Pitch";pitchdir=-1;
Roll="Roll";rolldir=1;
Yaw="Yaw";yawdir=1;
}
if (gyroforward==backward)
{
Pitch="Pitch";pitchdir=1;
Roll="Roll";rolldir=-1;
Yaw="Yaw";yawdir=1;
}
}
else if (gyroup==down)
{
if (gyroforward==left)
{
Pitch="Roll";rolldir=1;
Roll="Pitch";pitchdir=-1;
Yaw="Yaw";yawdir=-1;
}
if (gyroforward==right)
{
Pitch="Roll";rolldir=-1;
Roll="Pitch";pitchdir=1;
Yaw="Yaw";yawdir=-1;
}
if (gyroforward==forward)
{
Pitch="Pitch";pitchdir=1;
Roll="Roll";rolldir=1;
Yaw="Yaw";yawdir=-1;
}
if (gyroforward==backward)
{
Pitch="Pitch";pitchdir=-1;
Roll="Roll";rolldir=-1;
Yaw="Yaw";yawdir=-1;
}
}
else if (gyroup==left)
{
if (gyroforward==forward)
{
Pitch="Yaw";yawdir=-1;
Yaw="Pitch";pitchdir=-1;
Roll="Roll";rolldir=1;
}
if (gyroforward==backward)
{
Pitch="Yaw";yawdir=-1;
Yaw="Pitch";pitchdir=1;
Roll="Roll";rolldir=-1;
}
if (gyroforward==up)
{
Pitch="Roll";yawdir=-1;
Yaw="Pitch";rolldir=-1;
Roll="Yaw";pitchdir=-1;
}
if (gyroforward==down)
{
Pitch="Roll";yawdir=-1;
Yaw="Pitch";rolldir=1;
Roll="Yaw";pitchdir=1;
}
}
else if (gyroup==right)
{
if (gyroforward==forward)
{
Pitch="Yaw";yawdir=1;
Yaw="Pitch";pitchdir=1;
Roll="Roll";rolldir=1;
}
if (gyroforward==backward)
{
Pitch="Yaw";yawdir=1;
Yaw="Pitch";pitchdir=-1;
Roll="Roll";rolldir=-1;
}
if (gyroforward==up)
{
Pitch="Roll";yawdir=1;
Yaw="Pitch";rolldir=-1;
Roll="Yaw";pitchdir=1;
}
if (gyroforward==down)
{
Pitch="Roll";yawdir=1;
Yaw="Pitch";rolldir=1;
Roll="Yaw";pitchdir=-1;
}
}
else if (gyroup==forward)
{
if (gyroforward==down)
{
Roll="Yaw";yawdir=-1;
Pitch="Pitch";pitchdir=-1;
Yaw="Roll";rolldir=1;
}
if (gyroforward==up)
{
Roll="Yaw";yawdir=-1;
Pitch="Pitch";pitchdir=1;
Yaw="Roll";rolldir=-1;
}
if (gyroforward==left)
{
Pitch="Yaw";rolldir=1;
Roll="Pitch";yawdir=-1;
Yaw="Roll";pitchdir=1;
}
if (gyroforward==right)
{
Pitch="Yaw";rolldir=-1;
Roll="Pitch";yawdir=-1;
Yaw="Roll";pitchdir=-1;
}
}
else if (gyroup==backward)
{
if (gyroforward==down)
{
Roll="Yaw";yawdir=1;
Pitch="Pitch";pitchdir=1;
Yaw="Roll";rolldir=1;
}
if (gyroforward==up)
{
Roll="Yaw";yawdir=1;
Pitch="Pitch";pitchdir=-1;
Yaw="Roll";rolldir=-1;
}
if (gyroforward==left)
{
Pitch="Yaw";rolldir=1;
Roll="Pitch";yawdir=1;
Yaw="Roll";pitchdir=-1;
}
if (gyroforward==right)
{
Pitch="Yaw";rolldir=-1;
Roll="Pitch";yawdir=1;
Yaw="Roll";pitchdir=1;
}
}
}
}
}
public class TrackingSystem
{
private Logger log;
private IMyCubeGrid cubeGrid;
private ShipComponents shipComponets;
bool iscmd;
Region currentRegion=null;
List<TrackedEntity> trackedEntities=new List<TrackedEntity>();
List<PlanetaryData> KnownPlanets=new List<PlanetaryData>();
string tracked_targets_logs="";
Dictionary<string,string> screen_texts;
PlanetaryData nearestPlanet;
Vector3D altitude=Vector3D.Zero;
public TrackingSystem(Logger log,IMyCubeGrid cubeGrid,ShipComponents shipComponets,bool iscommand)
{
iscmd=iscommand;
this.log=log;
this.cubeGrid=cubeGrid;
this.shipComponets=shipComponets;
screen_texts=new Dictionary<string,string>();
}
internal bool IsOperational()
{
return (shipComponets.Sensors.Count()+shipComponets.Cameras.Count()) > 0;//trackedEntities.Count()>0 || KnownPlanets.Count()>0;
}
public void TrackEntity(TrackedEntity pm,bool selfcalled)
{
if (!pm.Name.ToLower().Contains("planet"))
UpdateTrackedEntity(pm);
if (pm.Name.ToLower().Contains("planet"))
UpdateSurfaceLocation(pm);
}
public void UpdateTrackedEntity(ParsedMessage pm)
{
TrackedEntity target=new TrackedEntity(pm.Location,pm.Velocity,pm.AttackPoint,pm.EntityId,pm.Name,(int)pm.ShipSize,pm.Relationship,pm.AttackPoint,pm.Type,log);
UpdateTrackedEntity(target);
}
public void UpdateTrackedEntity(TrackedEntity pm)
{
var id=pm.EntityID;
TrackedEntity existing=trackedEntities.Where(x => x.EntityID==id).FirstOrDefault();
if (existing==null)
{
existing=pm;
trackedEntities.Add(pm);
}
existing.Location=pm.Location;
existing.Velocity=pm.Velocity;
existing.LastUpdated=DateTime.Now;
existing.Radius=pm.Radius;
existing.Relationship=pm.Relationship;
if (pm.AttackPoint != Vector3D.Zero)
{
existing.UpdatePoints(new PointOfInterest(pm.AttackPoint,0));
}
}
public void UpdateSurfaceLocation(TrackedEntity pm)
{
var point=new PointOfInterest(pm.AttackPoint,pm.EntityID);
PlanetaryData planet=KnownPlanets.FirstOrDefault(x => x.PlanetCenter==pm.Location);
Region region=null;
region=new Region(pm.EntityID,pm.Location,point,iscmd,cubeGrid.GetPosition(),log);
if(planet !=null)
planet.UpdatePlanetaryData(region,cubeGrid.GetPosition());
if (planet==null) {
planet=CreateNewPlanet(pm.EntityID,pm.Location,region,point,cubeGrid.GetPosition());
if (currentRegion.EntityId==pm.EntityID)
{
currentRegion.UpdatePoints(point);
}
}
if (KnownPlanets.Count > 1)
nearestPlanet=KnownPlanets.OrderBy(x => (x.PlanetCenter-pm.Location).Length()).FirstOrDefault();
}
public void UpdateSurfaceLocation(ParsedMessage pm)
{
TrackedEntity target=new TrackedEntity(pm.Location,pm.Velocity,pm.AttackPoint,pm.EntityId,pm.Name,(int)pm.ShipSize,pm.Relationship,pm.AttackPoint,pm.Type,log);
UpdateSurfaceLocation(target);
}
private PlanetaryData CreateNewPlanet(long id,Vector3D loc,Region newregion,PointOfInterest point,Vector3D cubegridLoc)
{
PlanetaryData planet=null;
planet=new PlanetaryData(log,loc,newregion,cubegridLoc);
currentRegion=newregion;
nearestPlanet=planet;
KnownPlanets.Add(planet);
return planet;
}
public PlanetaryData GetNearestPlanet()
{
return nearestPlanet;
}
public void Update()
{
if (nearestPlanet != null)
altitude=(nearestPlanet.GetNearestPoint(cubeGrid.GetPosition())-cubeGrid.GetPosition());
long msStop=DateTime.Now.Ticks;
long timeTaken=msStop-last_slow_update;
if (timeTaken>=3000)
{
SlowUpdate();
last_slow_update=msStop;
}
}
long last_slow_update=DateTime.Now.Ticks;
public void SlowUpdate()
{
UpdateTrackedEntitiesScreens();
}
internal double GetAltitude()
{
return Math.Abs(altitude.Length());
}
internal Vector3D GetAltitudeIncDir()
{
return altitude;
}
internal List<TrackedEntity> getTargets()
{
return trackedEntities;
}
internal TrackedEntity GetEntity(long targetEntityID)
{
return trackedEntities.Where(x => x.EntityID==targetEntityID).FirstOrDefault();
}
internal Dictionary<string,string> GetScreenInfo()
{
screen_texts.Clear();
screen_texts.Add("tracked_grids",tracked_targets_logs);
return screen_texts;
}
private void UpdateTrackedEntitiesScreens()
{
tracked_targets_logs="ID,Type,Name,Relationship,Distance,Last Updated (s)\n\n";
foreach (var ent in trackedEntities.OrderBy(x => x.Relationship))
{
var near=ent.GetNearestPoint(cubeGrid.GetPosition());
var distance=(int)(near-cubeGrid.GetPosition()).Length();
var lastfour=(ent.EntityID+"");
lastfour=lastfour.Substring(lastfour.Length-4);
var record=lastfour+","+ent.Type+","+ent.Name+","+ent.Relationship+","+(int)distance+"m,"+(int)(DateTime.Now-ent.LastUpdated).TotalSeconds;
tracked_targets_logs=tracked_targets_logs+record+"\n";
}
}
public List<TrackedEntity> getCombatTargets(Vector3D point)
{
var targetsOfConcern=trackedEntities.Where(x => (x.GetNearestPoint(point)-point).Length() < 3000 && x.Radius > 50 && x.Relationship != MyRelationsBetweenPlayerAndBlock.Owner && (DateTime.Now-x.LastUpdated).TotalMinutes < 5);
return targetsOfConcern.ToList();
}
internal PointOfInterest GetNextMiningSamplePoint(Vector3D point)
{
var nearestUncheckedRegions=GetNearestPlanet().Regions
.OrderBy(x => (x.Value.surfaceCenter-point).Length())
.Where(x => x.Value.PointsOfInterest.Count(y => y.Mined) < 5);
if (nearestUncheckedRegions.Any())
{
var nearestUncheckedRegion=nearestUncheckedRegions.FirstOrDefault();
var surveyPoints=nearestUncheckedRegion.Value.PointsOfInterest.Where(x => !x.Mined && !x.HasPendingOrder).OrderBy(x => (x.Location-point).Length());
return surveyPoints.Any() ? surveyPoints.First() : null;
}
return null;
}
internal PointOfInterest GetNearestScanPoint(Vector3D point,int maxDistance)
{
var needToBeScanned=
GetNearestPlanet().Regions.OrderBy(x => (x.Value.surfaceCenter-point).Length()).Take(10)
.Where(x => x.Value.PointsOfInterest.Any(y => (DateTime.Now-y.Timestamp).TotalMinutes > 20));
PointOfInterest retrn=null;
if (needToBeScanned.Any())
{
var nearestUncheckedRegion=needToBeScanned.First();
var surveyPoints=nearestUncheckedRegion.Value.PointsOfInterest.Where(x => !x.HasPendingOrder && (x.Location-point).Length()<maxDistance);
var weightedByImportance=surveyPoints.OrderBy(x => (x.Location-point).Length());
retrn=surveyPoints.Any() ? surveyPoints.First() : null;
retrn.HasPendingOrder=true;
}
return retrn;
}
internal void UpdateScanPoint(PointOfInterest pointOfIntrest)
{
if (currentRegion != null)
{
var pointOfIntrestToUpdate=currentRegion.PointsOfInterest.Where(x => x.Location==pointOfIntrest.Location).FirstOrDefault();
currentRegion.PointsOfInterest.Remove(pointOfIntrestToUpdate);
currentRegion.PointsOfInterest.Add(pointOfIntrest);
}
}
}
public class WeaponSystem
{
private Logger log;
private IMyCubeGrid cubeGrid;
private ShipComponents shipComponets;
public WeaponSystem(Logger log,IMyCubeGrid cubeGrid,ShipComponents shipComponets)
{
this.log=log;
this.cubeGrid=cubeGrid;
this.shipComponets=shipComponets;
}
internal bool IsOperational()
{
return (shipComponets.GatlingGuns.Count()+shipComponets.RocketLaunchers.Count()) > 0;
}
internal void Engage()
{
foreach (var weapon in shipComponets.GatlingGuns)
{
((IMySmallGatlingGun)weapon).GetActionWithName("Shoot_On").Apply(weapon);
}
foreach (var weapon in shipComponets.RocketLaunchers)
{
((IMySmallMissileLauncher)weapon).GetActionWithName("ShootOnce").Apply(weapon);
}
}
internal void Disengage()
{
foreach (var weapon in shipComponets.GatlingGuns)
{
(weapon).GetActionWithName("Shoot_Off").Apply(weapon);
}
foreach (var weapon in shipComponets.RocketLaunchers)
{
(weapon).GetActionWithName("Shoot_Off").Apply(weapon);
}
}
}
public class CommunicationSystem
{
List<String> PendingMessages=new List<String>();
private String lastmessageOnHold=null;
ShipComponents components;
int messagesSent=0;
int messagesRecieved=0;
public ParsedMessage ParseMessage(string argument)
{
ParsedMessage pm=new ParsedMessage(argument,L);
messagesRecieved++;
return pm;
}
public void SendMessage(string m)
{
PendingMessages.Add(m);
}
public void TransmitOrder(DroneOrder m,long commandID)
{
PendingMessages.Add(ParsedMessage.CreateEncryptedOrder(m,commandID));
}
Logger L;
IMyCubeGrid grid;
public CommunicationSystem(Logger l,IMyCubeGrid _grid,ShipComponents componets)
{
L=l;
grid=_grid;
this.components=componets;
}
public void SendAwakeningMessage()
{
PendingMessages.Add(ParsedMessage.CreateAwakeningMessage());
}
public List<String> RetrievePendingMessages()
{
return PendingMessages;
}
public void EmptyPendingMessages()
{
PendingMessages.Clear();
}
internal bool IsOperational()
{
return components.RadioAntennas.Any();
}
int numberMessagesSent=0;
internal int GetMsgSntCount()
{
numberMessagesSent++;
return numberMessagesSent;
}
}
public class ShipComponents
{
public List<IMyTextPanel> TextPanels=new List<IMyTextPanel>();
public List<IMySensorBlock> Sensors=new List<IMySensorBlock>();
public List<IMyCameraBlock> Cameras=new List<IMyCameraBlock>();
public List<IMyProgrammableBlock> ProgramBlocks=new List<IMyProgrammableBlock>();
public List<IMyRadioAntenna> RadioAntennas=new List<IMyRadioAntenna>();
public List<IMyLaserAntenna> LaserAntennas=new List<IMyLaserAntenna>();
public List<IMyRemoteControl> ControlUnits=new List<IMyRemoteControl>();
public List<IMyShipConnector> Connectors=new List<IMyShipConnector>();
public List<IMyShipDrill> MiningDrills=new List<IMyShipDrill>();
public List<IMyThrust> Thrusters=new List<IMyThrust>();
public List<IMyGyro> Gyros=new List<IMyGyro>();
public List<IMyShipMergeBlock> MergeBlocks=new List<IMyShipMergeBlock>();
public List<IMySmallGatlingGun> GatlingGuns=new List<IMySmallGatlingGun>();
public List<IMySmallMissileLauncher> RocketLaunchers=new List<IMySmallMissileLauncher>();
public List<IMyTerminalBlock> AllBlocks=new List<IMyTerminalBlock>();
public List<IMyTerminalBlock> AllMyBlocks=new List<IMyTerminalBlock>();
public List<IMyReactor> Reactors=new List<IMyReactor>();
public List<IMyBatteryBlock> Batteries=new List<IMyBatteryBlock>();
public List<IMyBlockGroup> Groups=new List<IMyBlockGroup>();
public void Sync(IMyGridTerminalSystem GridTerminalSystem,IMyCubeGrid grid)
{
MergeBlocks.Clear();
MiningDrills.Clear();
GatlingGuns.Clear();
RocketLaunchers.Clear();
ProgramBlocks.Clear();
LaserAntennas.Clear();
RadioAntennas.Clear();
TextPanels.Clear();
ControlUnits.Clear();
Connectors.Clear();
Sensors.Clear();
Gyros.Clear();
Thrusters.Clear();
Cameras.Clear();
AllBlocks.Clear();
AllMyBlocks.Clear();
Reactors.Clear();
Batteries.Clear();
Groups.Clear();
GridTerminalSystem.GetBlocks(AllBlocks);
GridTerminalSystem.GetBlocksOfType(AllMyBlocks,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(MergeBlocks,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(Cameras,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(Gyros,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(Thrusters,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(Sensors,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(Connectors,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(ProgramBlocks,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(LaserAntennas,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(RadioAntennas,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(TextPanels,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(ControlUnits,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(MiningDrills,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(GatlingGuns,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(RocketLaunchers,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(Reactors,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlocksOfType(Batteries,b => b.CubeGrid==grid);
GridTerminalSystem.GetBlockGroups(Groups);
foreach (var sensor in Sensors)
{
sensor.DetectEnemy=true;
sensor.DetectPlayers=true;
sensor.DetectLargeShips=true;
sensor.DetectSmallShips=true;
sensor.DetectOwner=true;
sensor.DetectStations=true;
sensor.DetectAsteroids=true;
sensor.BackExtend=50;
sensor.FrontExtend=50;
sensor.LeftExtend=50;
sensor.RightExtend=50;
sensor.TopExtend=50;
sensor.BottomExtend=50;
}
}
}
public class Logger
{
public Logger(IMyCubeGrid grid)
{
Debug("Logger Set Up!");
}
public Logger(IMyCubeGrid grid,ShipComponents components)
{
this.grid=grid;
this.components=components;
}
int loglimit=25;
private List<IMyTextPanel> textPanels;
private ShipComponents components;
private List<String> debug=new List<String>();
private List<String> error=new List<String>();
private IMyCubeGrid grid;
public void Debug(String m)
{
debug.Add(DateTime.Now+" :- "+m);
if (debug.Count > loglimit)
debug.Remove(debug[0]);
}
public void Error(String m)
{
error.Add(m);
if (error.Count > loglimit)
error.Remove(error[0]);
}
public void DisplayLogScreens()
{
var debugScreens=components.TextPanels.Where(x => x.CustomName.Contains("#debug#")).ToList();
var errorScreens=components.TextPanels.Where(x => x.CustomName.Contains("#error#")).ToList();
UpdateLCD(debug,debugScreens,"Debug Messages");
UpdateLCD(error,errorScreens,"Error Messages");
}
public void DisplayTargets(List<TrackedEntity> trackedEntities)
{
var targetsScreens=components.TextPanels.Where(x => x.CustomName.Contains("#targets#")).ToList();
}
public void UpdateDisplays(List<IMyTextPanel> _textpanels,List<DroneInfo> drones,List<Order> orders,List<TrackedEntity> trackedEntities,IMyCubeGrid grid)
{
textPanels=_textpanels;
var debugScreens=textPanels.Where(x => x.CustomName.Contains("#debug#")).ToList();
var targetsScreens=textPanels.Where(x => x.CustomName.Contains("#targets#")).ToList();
var errorScreens=textPanels.Where(x => x.CustomName.Contains("#error#")).ToList();
if (orders != null)
{
var fleetScreens=textPanels.Where(x => x.CustomName.Contains("#fleet#")).ToList();
}
}
private int lastInfoIndex=0;
private int maxInfoLength=10;
internal void DisplayShipInfo(Dictionary<string,object> infoKeys,string title="Ship Info")
{
var Cameras=components.Cameras.Count();
var Connectors=components.Connectors.Count();
var ControlUnits=components.ControlUnits.Count();
var Gyros=components.Gyros.Count();
var MergeBlocks=components.MergeBlocks.Count();
var MiningDrills=components.MiningDrills.Count();
var Thrusters=components.Thrusters.Count();
List<String> lines=new List<string>();
lines.Add(" Cameras: "+Cameras);
lines.Add(" Connectors: "+Connectors);
lines.Add(" ControlUnits: "+ControlUnits);
lines.Add(" Gyros: "+Gyros);
lines.Add(" MergeBlocks: "+MergeBlocks);
lines.Add(" MiningDrills: "+MiningDrills);
lines.Add(" Thrusters: "+Thrusters);
foreach (var obj in infoKeys)
lines.Add(" "+obj.Key+": "+obj.Value);
var lcds=components.TextPanels.Where(x => x.CustomName.Contains("#info#")).ToList();
UpdateLCD(lines,lcds," "+title+" "+grid.CustomName);
}
internal void DisplayLogs(List<IMyTextPanel> textPanels,Dictionary<string,string> all_refs)
{
String str="";
int index=0;
foreach (var screen in textPanels)
{
if (all_refs.ContainsKey(screen.CustomName))
screen.WriteText(screen.CustomName+"\n"+DateTime.Now+"\n"+all_refs[screen.CustomName]);
}
}
public void UpdateProductionInfo(FactorySystem factorySystem,IMyCubeGrid grid)
{
List<string> lines=new List<string>();
lines.Add(" Number of Factories: "+factorySystem.Factories.Count());
foreach(var factory in factorySystem.Factories){
Factory fact=factory.Value;
lines.Add(factory.Key+" "+fact.IsOperational()+" "+fact.currentState+" "+fact.CompCounts());
if(fact.GetPrimaryProjector()!=null)
lines.Add("--Blocks to Build--"+fact.GetPrimaryProjector().RemainingBlocks);
foreach (var type in fact.GetPrimaryProjector().RemainingBlocksPerType)
{
lines.Add(" --missing--"+type.Value+ " "+(type.Key.ToString()+"").Split('/')[1]);
}
lines.Add(" --missing--"+ fact.GetPrimaryProjector().RemainingArmorBlocks+" Armor" );
}
var screens=components.TextPanels.Where(x => x.CustomName.Contains("#production#")).ToList();
UpdateLCD(lines,screens,"Production");
}
public void UpdateRegionInfo(Dictionary<long,Region> regions,IMyCubeGrid grid)
{
List<string> lines=new List<string>();
foreach (var ent in regions.OrderByDescending(x => (x.Value.PointsOfInterest).Count).Take(10))
{
var near=ent.Value.GetNearestPoint(grid.GetPosition());
var distance=(int)(near-grid.GetPosition()).Length();
lines.Add(" size: "+ent.Value.PointsOfInterest.Count()+" distance: "+(int)distance+"m\n" +
" --last scanned: "+(int)(DateTime.Now-ent.Value.LastUpdated).TotalSeconds+"s " +
"scan density: "+ent.Value.GetScanDensity()+"\n" +
" --surface scan coverage: "+ent.Value.GetPercentReached());
}
lines.Add(" Number of Detected Regions: "+regions.Count());
var screens=components.TextPanels.Where(x => x.CustomName.Contains("#planets#")).ToList();
UpdateLCD(lines,screens,"Regions");
}
public void UpdateFleetInformationScreens(List<DroneContext> droneContexts,IMyCubeGrid grid)
{
List<IMyTextPanel> fleetScreens=components.TextPanels.Where(x => x.CustomName.Contains("#fleet#")).ToList();
var droneinfos="";
var drones=droneContexts.Select(x => x.Info).ToList();
var orders=droneContexts.Where(x => x.Order != null).Select(x => x.Order).ToList();
foreach (var drone in drones)
{
var distance=(int)(drone.lastKnownPosition-grid.GetPosition()).Length();
int velocity=(int)(Math.Abs(drone.LastKnownVector.X)+Math.Abs(drone.LastKnownVector.Y)+Math.Abs(drone.LastKnownVector.Z));
droneinfos += "| "+drone.EntityId+" |"+drone.Type+" |"+(int)(drone.Health*100)+"% |"+drone.numSensors+"|"+drone.CameraCount+"|"+drone.NumDrills+" | "+drone.Guns+" | "+drone.Rockets+" |"+(int)((drone.PercentCargo / drone.StorageMax)*100)+"% | "+drone.StorageMax+" | "+drone.CurrentPower+" | "+drone.MaxPower+" | "+drone.Batteries+"|"+(int)((drone.CurrentPower / drone.MaxPower)*100)+"% power |"+drone.Merge+" |"+velocity+"/"+distance+" | "+(drone.Docked ? "Docked" : "un-docked")+"\n";
}
if (drones.Count==0)
droneinfos="| No Drone Info |";
var missioninfos="";
foreach (var order in orders)
{
var drone=drones.FirstOrDefault(x => x.EntityId==order.DroneId);
var distancefromDrone="";
var distancefromCC="";
if (drone != null)
{
distancefromDrone=(int)(drone.lastKnownPosition-order.PrimaryLocation).Length()+"";
distancefromCC=(int)(grid.GetPosition()-order.PrimaryLocation).Length()+"";
}
int velocity=(int)(Math.Abs(drone.LastKnownVector.X)+Math.Abs(drone.LastKnownVector.Y)+Math.Abs(drone.LastKnownVector.Z));
missioninfos += "| "+drone.EntityId+" |"+order.Ordertype+" |"+(int)((DateTime.Now-order.IssuedAt).TotalSeconds)+"|"+order.Confirmed+"| "+distancefromCC+"|"+distancefromDrone +" |\n";
}
if (drones.Count==0)
missioninfos="| No Mission Info |";
var scanorders=orders.Where(x => x.Ordertype==OrderType.Scan).Count();
var fleet=new List<string> {"| Fleet Information |",
"| Num Drones "+ "| Active Orders|",
"| "+drones.Count+" "+ "| "+orders.Count+"|\n",
"| Drone Information |",
"|Drone Id| HP|Type | Sensors | Cameras | Drills | Weapons | cargo | Vel/Dis",
droneinfos,
"| Outstanding Orders |",
"|Drone Id| Order Type "+ "| Mission Time "+ "| Confirmed | Target-D | Drone-D |",
missioninfos};
UpdateLCD(fleet,fleetScreens,"");
}
public void UpdateLCD(List<string> logs,List<IMyTextPanel> lcds,string headerString)
{
String str="";
int index=0;
foreach (var strin in logs)
{
if (index < loglimit)
str += strin+"\n";
else continue;
}
if (lcds != null)
foreach (var screen in lcds)
screen.WritePublicText(headerString+"\n"+DateTime.Now+"\nLogcount: "+logs.Count()+"\n"+str);
}
internal void UpdateAltitudeLCD(double altitude,List<IMyTextPanel> textPanels)
{
var screens=textPanels.Where(x => x.CustomName.Contains("#altitude#")).ToList();
if (screens != null && screens.Count() > 0)
{
screens.First().WritePublicText(" Altitude:\n "+altitude+"");
}
}
}
public enum MessageCode
{
Register,
Confirmation,
Update,
PingEntity,
Order,
Unknown
}
public class TrackedEntity
{
public Vector3D Location;
public Vector3D Velocity;
public Vector3D AttackPoint;
public List<PointOfInterest> PointsOfInterest=new List<PointOfInterest>();
public DateTime LastUpdated;
public String DetailsString;
public long EntityID;
public String Name;
public int Radius;
Vector3D nearestPoint;
public MyRelationsBetweenPlayerAndBlock Relationship;
Logger log;
public String Type;
public TrackedEntity(Vector3D location,Vector3D velocity,Vector3D attack_point,long entityId,String name,int radius,MyRelationsBetweenPlayerAndBlock relationship,Vector3D nearest_point,String type,Logger log)
{
AttackPoint=attack_point;
this.log=log;
LastUpdated=DateTime.Now;
Location=location;
Velocity=velocity;
EntityID=entityId;
Name=name;
Radius=radius;
Relationship=relationship;
nearestPoint=nearest_point;
Type=type;
UpdatePoints(new PointOfInterest(nearestPoint,EntityID));
}
public void UpdatePoints(PointOfInterest pointOfInterest)
{
PointsOfInterest.Add(pointOfInterest);
while (PointsOfInterest.Count > 5)
PointsOfInterest.RemoveAt(0);
}
internal Vector3D GetNearestPoint(Vector3D vector3D)
{
return PointsOfInterest.OrderBy(x => Math.Abs((vector3D-x.Location).Length())).FirstOrDefault().Location;
}
}
public class PointOfInterest
{
public Vector3D Location;
public DateTime Timestamp=DateTime.Now.AddMinutes(-61);
public long regionEntityID=0;
public bool Reached=false;
public bool HasPendingOrder=false;
public bool Mined=false;
public PointOfInterest(Vector3D Loc,long regionEntityID)
{
Location=Loc;
this.regionEntityID=regionEntityID;
}
}
public class Order
{
public static DateTime starttime=DateTime.Now;
public static int OrderIdIndex=0;
public double orderid;
public OrderType Type=OrderType.Unknown;
public long DroneID;
public IMyShipConnector Connector=null;
public long TargetEntityID;
public bool DockRouteSet=false;
public Vector3D OrderLocation;
public Vector3D AlignTo;
public Vector3D AlignUp;
public bool Confirmed=false;
public DateTime IssuedAt=DateTime.Now;
public DateTime LastUpdated=DateTime.Now;
public List<PointOfInterest> MiningPoints=new List<PointOfInterest>();
public bool ReachedPrepPosition=false;
public Order(OrderType typ,long droneid,Vector3D orderloc,Vector3D alignto,Vector3D alignup,IMyShipConnector connector=null)
{
DroneID=droneid;
orderid=(DateTime.Now-starttime).TotalSeconds;
Connector=connector;
Type=typ;
OrderLocation=orderloc;
AlignTo=alignto;
AlignUp=alignup;
if (typ==OrderType.Mine)
InitalizeMiningOrder();
}
public Order(OrderType typ,long droneid,Vector3D orderloc,Vector3D alignto,Vector3D alignup,long Entityid,IMyShipConnector connector=null)
{
DroneID=droneid;
orderid=(DateTime.Now-starttime).TotalSeconds;
Connector=connector;
Type=typ;
OrderLocation=orderloc;
AlignTo=alignto;
AlignUp=alignup;
TargetEntityID=Entityid;
if (typ==OrderType.Mine)
InitalizeMiningOrder();
}
public List<DockVector> DockRoute=new List<DockVector>();
public Order(OrderType typ,double orderid,long droneid,Vector3D orderloc,Vector3D alignto,Vector3D alignup)
{
DroneID=droneid;
this.orderid=orderid;
Type=typ;
OrderLocation=orderloc;
AlignTo=alignto;
AlignUp=alignup;
dockpushoutrange=(int)(orderloc-alignto).Length();
}
int dockpushoutrange;
int dockSplitCount=20;
public void InitalizeDockRoute(Vector3D startLocation)
{
DockRouteSet=true;
DockRoute.Add(new DockVector(startLocation));
DockRoute.Add(new DockVector(OrderLocation+(AlignTo*50)));
DockRoute.Add(new DockVector(OrderLocation+(AlignTo*2)));
}
public void InitalizeMiningOrder()
{
var dirToPlanet=OrderLocation-AlignTo;
dirToPlanet.Normalize();
var bottomOfHoleVector=OrderLocation+(dirToPlanet*20);
var distance=bottomOfHoleVector.Normalize();
for (int i=0;i < distance;i=i+2)
MiningPoints.Add(new PointOfInterest(OrderLocation+(dirToPlanet*i),0));
}
int dockindex=0;
public Vector3D GetCurrentDockPoint(Vector3D shipPosition)
{
var current=DockRoute[dockindex];
if ((shipPosition-current.Location).Length()<=0.001 && dockindex < (DockRoute.Count-1))
{
dockindex++;
current=DockRoute[dockindex];
}
return current.Location;
}
}
public enum DroneType
{
Miner,Scan,Combat,Unknown
}
public class DroneInfo
{
public long EntityId;
public DroneType Type=DroneType.Unknown;
public Vector3D lastKnownPosition=Vector3D.Zero;
public Vector3D LastKnownVector=Vector3D.Zero;
public DateTime lastUpdated=DateTime.Now;
public String Status="none";
public String Name;
public bool Docked=false;
public int NumConnectors=0;
public int NumDrills=0;
public int NumWeapons=0;
public int numSensors=0;
public double ShipSize=0;
public double PercentCargo=0;
public int CameraCount=0;
public bool Unloaded=false;
public double Health=0;
public double StorageMax=0;
public int Merge=0;
public int Guns=0;
public int Rockets=0;
public int Reactors=0;
public int Batteries=0;
public double CurrentPower=0;
public double MaxPower=0;
public DroneInfo(long id,String name,Vector3D location,Vector3D velocity)
{
EntityId=id;
Name=name;
lastKnownPosition=location;
LastKnownVector=velocity;
}
public void Update(String name,Vector3D location,Vector3D velocity,bool docked,int cameraCount,double shipsize,int drillcount,int weaponCount,int sensorCount,int connectorCount,double percentCargo
,double health,double storagemax,int merge,int guns,int rockets,int reactors,int batteries,double currentpower,double maxpower)
{
CameraCount=cameraCount;
PercentCargo=percentCargo;
Name=name;
lastKnownPosition=location;
LastKnownVector=velocity;
Docked=docked;
ShipSize=shipsize;
NumWeapons=weaponCount;
NumDrills=drillcount;
numSensors=sensorCount;
NumConnectors=connectorCount;
lastUpdated=DateTime.Now;
Health=health;
StorageMax=storagemax;
Merge=merge;
Guns=guns;
Rockets=rockets;
Reactors=reactors;
Batteries=batteries;
CurrentPower=currentpower;
MaxPower=maxpower;
}
}
public enum OrderType
{
FlyTo,
AlignTo,
Dock,
Undock,
Mine,
Scan,
Attack,
Unknown,
Standby
}
public enum FactoryState
{
ReadyToBuild,
Building,
Releasing,
Starting,
Unknown,
ReadyToLaunch,
Launching,
Complete
}
public class ParsedMessage
{
Dictionary<String,String> messageElements=new Dictionary<string,string>();
Logger LOG;
public MessageCode MessageType=MessageCode.Unknown;
public OrderType OrderType=OrderType.Unknown;
public double RequestID=0;
public long EntityId=0;
public long TargetEntityId=0;
public String Name=null;
public Vector3D Location=Vector3D.Zero;
public Vector3D Velocity=Vector3D.Zero;
public Vector3D AttackPoint=Vector3D.Zero;
public String Status=null;
public long CommanderId=0;
public String MessageString;
public String BounceString;
public int NumBounces=0;
public static int MaxNumBounces=2;
public bool IsAwakeningSignal=false;
public int TargetRadius=0;
public Vector3D AlignForward=Vector3D.Zero;
public Vector3D AlignUp=Vector3D.Zero;
public bool Docked=false;
public int ConnectorCount=0;
public int DrillCount=0;
public int SensorCount=0;
public int CameraCount=0;
public double ShipSize=0;
public int WeaponCount=0;
public double PercentCargo=0;
public double HP=0;
public double MaxStorage=0;
public int MergeCount=0;
public int GuneCount=0;
public int RocketCount=0;
public int ReactorCount=0;
public int BatteryCount=0;
public double CurrentPower=0;
public double MaxPower=0;
public string Type;
public MyRelationsBetweenPlayerAndBlock Relationship=MyRelationsBetweenPlayerAndBlock.Neutral;
const String MESSAGETYPE_FLAG="11";
const string ORDERTYPE_FLAG="110";
const String REQUESTID_FLAG="12";
const String NAME_FLAG="13";
const String LOCATION_FLAG="14";
const String ATTACKPOINT_FLAG="16";
const String VELOCITY_FLAG="15";
const String ENTITYID_FLAG="17";
const String TARGETID_FLAG="19";
const String COMMANDID_FLAG="111";
const String STATUS_FLAG="18";
const String MAXBOUNCE_FLAG="113";
const String NUMBOUNCES_FLAG="114";
const String TARGETRADIUS_FLAG="115";
const String ALIGNFORWARDVECTOR_FLAG="116";
const String ALIGNUPVECTOR_FLAG="117";
const String DOCKEDSTATUS_FLAG="118";
const String SHIPSIZE_FLAG="122";
const String PERCENTCARGO_FLAG="546";
const String AWAKENING_FLAG="666";
const String RELATIONSHIP_FLAG="fof";
const String TYPE_FLAG="126";
const String REGISTER_FLAG="21";
const String CONFIRMATION_FLAG="22";
const String UPDATE_FLAG="23";
const String PINGENTITY_FLAG="24";
const String ORDER_FLAG="25";
const String NUMCONNECTORS_FLAG="119";
const String NUMMININGDRILLS_FLAG="120";
const String NUMSENSORS_FLAG="121";
const String NUMWEAPONS_FLAG="124";
const String NUMROCKETLAUNCHERS_FLAG="123";
const String NUMCAMERA_FLAG="125";
const String HP_FLAG="1112";
const String STORAGEMX_FLAG="1113";
const String MERGE_FLAG="1114";
const String GUNS_FLAG="1115";
const String ROCKET_FLEG="1116";
const String REACTOR_FLAG="1117";
const String BATTERY_FLAG="1118";
const String CURPOWER_FLAG="1119";
const String MAXPOWER_FLAG="1120";
const String DOCKORDER="26";
const String UNDOCKORDER="u26";
const String ATTACKORDER="27";
const String MININGORDER="28";
const String ALIGNTOORDER="30";
const String FLYTOORDER="29";
const String SCANTOORDER="31";
const String STANDBYORDER="34";
public ParsedMessage(String message,Logger log)
{
LOG=log;
MessageString=message;
String messageNoBrackets=message.Replace("{","").Replace("}","");
ReadProperties(messageNoBrackets);
foreach (var pair in messageElements)
{
try
{
switch (pair.Key)
{
case MESSAGETYPE_FLAG:
ParseMessageType(pair.Value);
break;
case ORDERTYPE_FLAG:
ParseOrderType(pair.Value);
break;
case REQUESTID_FLAG:
RequestID=double.Parse(pair.Value);
break;
case ENTITYID_FLAG:
EntityId=long.Parse(pair.Value);
break;
case PERCENTCARGO_FLAG:
PercentCargo=double.Parse(pair.Value);
break;
case COMMANDID_FLAG:
CommanderId=long.Parse(pair.Value);
break;
case RELATIONSHIP_FLAG:
MyRelationsBetweenPlayerAndBlock.TryParse(pair.Value,out Relationship);
break;
case TARGETID_FLAG:
TargetEntityId=long.Parse(pair.Value);
break;
case NUMMININGDRILLS_FLAG:
DrillCount=int.Parse(pair.Value);
break;
case NUMSENSORS_FLAG:
SensorCount=int.Parse(pair.Value);
break;
case NUMCONNECTORS_FLAG:
ConnectorCount=int.Parse(pair.Value);
break;
case NUMBOUNCES_FLAG:
NumBounces=(int)double.Parse(pair.Value);
break;
case SHIPSIZE_FLAG:
ShipSize=double.Parse(pair.Value);
break;
case MAXBOUNCE_FLAG:
MaxNumBounces=(int)double.Parse(pair.Value);
break;
case TYPE_FLAG:
Type=pair.Value;
break;
case NUMCAMERA_FLAG:
CameraCount=int.Parse(pair.Value);
break;
case ATTACKPOINT_FLAG:
AttackPoint=TryParseVector(pair.Value);
break;
case NAME_FLAG:
Name=pair.Value;
break;
case LOCATION_FLAG:
Location=TryParseVector(pair.Value);
break;
case VELOCITY_FLAG:
Velocity=TryParseVector(pair.Value);
break;
case DOCKEDSTATUS_FLAG:
Docked=bool.Parse(pair.Value);
break;
case STATUS_FLAG:
Status=pair.Value;
break;
case ALIGNFORWARDVECTOR_FLAG:
AlignForward=TryParseVector(pair.Value);
break;
case ALIGNUPVECTOR_FLAG:
AlignUp=TryParseVector(pair.Value);
break;
case AWAKENING_FLAG:
IsAwakeningSignal=true;
break;
case TARGETRADIUS_FLAG:
TargetRadius=(int)double.Parse(pair.Value);
break;
case NUMWEAPONS_FLAG:
WeaponCount=int.Parse(pair.Value);
break;
case HP_FLAG:
HP=double.Parse(pair.Value);
break;
case STORAGEMX_FLAG:
MaxStorage=double.Parse(pair.Value);
break;
case MERGE_FLAG:
MergeCount=int.Parse(pair.Value);
break;
case GUNS_FLAG:
GuneCount=int.Parse(pair.Value);
break;
case ROCKET_FLEG:
RocketCount=int.Parse(pair.Value);
break;
case REACTOR_FLAG:
ReactorCount=int.Parse(pair.Value);
break;
case BATTERY_FLAG:
BatteryCount=int.Parse(pair.Value);
break;
case CURPOWER_FLAG:
CurrentPower=double.Parse(pair.Value);
break;
case MAXPOWER_FLAG:
MaxPower=double.Parse(pair.Value);
break;
default:
return;
}
}
catch (Exception e)
{
log.Error("Error parsing Communications\n"+e.Message+" "+pair.Key+":"+pair.Value);
}
}
}
internal static string CreateUpdateMessage(long droneID,long commandShipId,bool docked,int requestid,double health,Vector3D speed,Vector3D position,
float gridSize,
double storageFull,double StorageMax,
int merge,int connect,
int drill,
int sensor,int camera,
int guns,int rockets,
int reactors,
int batteries,double curPower,double maxPower,bool isRegister=false)
{
String msgStr="";
if (isRegister)
msgStr += MESSAGETYPE_FLAG+":"+REGISTER_FLAG;
else
msgStr += MESSAGETYPE_FLAG+":"+UPDATE_FLAG;
msgStr += ","+HP_FLAG+":"+health;
msgStr += ","+STORAGEMX_FLAG+":"+StorageMax;
msgStr += ","+MERGE_FLAG+":"+merge;
msgStr += ","+GUNS_FLAG+":"+guns;
msgStr += ","+ROCKET_FLEG+":"+rockets;
msgStr += ","+REACTOR_FLAG+":"+reactors;
msgStr += ","+BATTERY_FLAG+":"+batteries;
msgStr += ","+CURPOWER_FLAG+":"+curPower;
msgStr += ","+MAXPOWER_FLAG+":"+maxPower;
msgStr += ","+ENTITYID_FLAG+":"+droneID;
msgStr += ","+COMMANDID_FLAG+":"+commandShipId;
msgStr += ","+SHIPSIZE_FLAG+":"+gridSize;
msgStr += ","+PERCENTCARGO_FLAG+":"+storageFull;
msgStr += ","+NUMCONNECTORS_FLAG+":"+connect;
msgStr += ","+NUMCAMERA_FLAG+":"+camera;
msgStr += ","+NUMSENSORS_FLAG+":"+sensor;
msgStr += ","+NUMMININGDRILLS_FLAG+":"+drill;
msgStr += ","+NUMWEAPONS_FLAG+":"+(guns+rockets);
msgStr += ","+DOCKEDSTATUS_FLAG+":"+docked;
msgStr += ","+REQUESTID_FLAG+":"+droneID+requestid;
msgStr += ","+NUMBOUNCES_FLAG+":"+0;
msgStr += ","+VELOCITY_FLAG+":"+VectorToString(speed);
msgStr += ","+LOCATION_FLAG+":"+VectorToString(position);
msgStr="{"+msgStr+"}";
return msgStr;
}
public void ParseMessageType(String messaget)
{
switch (messaget)
{
case REGISTER_FLAG:
MessageType=MessageCode.Register;
break;
case CONFIRMATION_FLAG:
MessageType=MessageCode.Confirmation;
break;
case UPDATE_FLAG:
MessageType=MessageCode.Update;
break;
case PINGENTITY_FLAG:
MessageType=MessageCode.PingEntity;
break;
case ORDER_FLAG:
MessageType=MessageCode.Order;
break;
}
}
public void ParseOrderType(string ordertype)
{
switch (ordertype)
{
case UNDOCKORDER:
OrderType=OrderType.Undock;
break;
case DOCKORDER:
OrderType=OrderType.Dock;
break;
case ATTACKORDER:
OrderType=OrderType.Attack;
break;
case SCANTOORDER:
OrderType=OrderType.Scan;
break;
case FLYTOORDER:
OrderType=OrderType.FlyTo;
break;
case MININGORDER:
OrderType=OrderType.Mine;
break;
case ALIGNTOORDER:
OrderType=OrderType.AlignTo;
break;
case STANDBYORDER:
OrderType=OrderType.Standby;
break;
}
}
public static String CreateAwakeningMessage()
{
String msgStr="";
msgStr += AWAKENING_FLAG+":"+0;
msgStr += ","+NUMBOUNCES_FLAG+":"+0;
return "{"+msgStr+"}";
}
private static String VectorToString(Vector3D vect)
{
String str=Math.Round(vect.X,4)+"|"+Math.Round(vect.Y,4)+"|"+Math.Round(vect.Z,4);
return str;
}
public bool IsValid()
{
if (MessageType != MessageCode.Unknown)
{
return true;
}
return false;
}
private Vector3D TryParseVector(String vector)
{
var splits=vector.Split('|');
try
{
if (splits.Count()==3)
{
var loc=new Vector3D(double.Parse(splits[0]),double.Parse(splits[1]),double.Parse(splits[2]));
return loc;
}
else
{
LOG.Error("Unable to parse into 3 splits: "+vector);
}
}
catch
{
LOG.Error("Unable to parse Location: "+vector);
}
return Vector3D.Zero;
}
public void ReadProperties(String message)
{
message=message.Trim();
if (message.Length < 3)
return;
String bouncemsg="{";
var splits=message.Split(',');
int index=0;
foreach (var pair in splits)
{
var clean=pair.Trim();
var keyval=clean.Split(':');
if (keyval.Length==2)
{
var key=keyval[0];
var value=keyval[1];
messageElements.Add(key,value);
if (index==0 && key==NUMBOUNCES_FLAG)
bouncemsg += key+":"+value+"";
else if (index==0)
bouncemsg += key+":"+value+"";
else if (key==NUMBOUNCES_FLAG)
bouncemsg += ","+key+":"+(int.Parse(value)+1)+"";
else
bouncemsg += ","+key+":"+value+"";
index++;
}
else
{
LOG.Error("failed to parse message {"+message+"} @ "+clean);
}
}
bouncemsg += "}";
BounceString=bouncemsg;
}
public override String ToString()
{
return BounceString;
}
internal static string CreateConfirmationMessage(long entityId,long targetEntity,double requestID)
{
String msgStr="";
msgStr += MESSAGETYPE_FLAG+":"+CONFIRMATION_FLAG;
msgStr += ","+ENTITYID_FLAG+":"+entityId;
msgStr += ","+TARGETID_FLAG+":"+targetEntity;
msgStr += ","+NUMBOUNCES_FLAG+":"+1;
msgStr += ","+REQUESTID_FLAG+":"+requestID;
return "{"+msgStr+"}";
}
internal static string CreateEncryptedOrder(DroneOrder order,long commandId)
{
string ordertype="";
switch (order.Ordertype)
{
case OrderType.AlignTo:
ordertype=ALIGNTOORDER;
break;
case OrderType.Dock:
ordertype=DOCKORDER;
break;
case OrderType.Undock:
ordertype=UNDOCKORDER;
break;
case OrderType.FlyTo:
ordertype=FLYTOORDER;
break;
case OrderType.Mine:
ordertype=MININGORDER;
break;
case OrderType.Scan:
ordertype=SCANTOORDER;
break;
case OrderType.Attack:
ordertype=ATTACKORDER;
break;
case OrderType.Standby:
ordertype=STANDBYORDER;
break;
}
var msgStr=MESSAGETYPE_FLAG+":"+ORDER_FLAG +
","+ORDERTYPE_FLAG+":"+ordertype +
","+TARGETID_FLAG+":"+order.TargetEntityID +
","+ALIGNFORWARDVECTOR_FLAG+":"+VectorToString(order.DirectionalVectorOne) +
","+ALIGNUPVECTOR_FLAG+":"+VectorToString(order.ThirdLocation) +
","+COMMANDID_FLAG+":"+commandId +
","+ENTITYID_FLAG+":"+order.DroneId +
","+REQUESTID_FLAG+":"+order.RequestId +
","+NUMBOUNCES_FLAG+":"+0 +
","+LOCATION_FLAG+":"+VectorToString(order.PrimaryLocation);
return "{"+msgStr+"}";
}
public static String CreateConfirmationMessage(String entityId,String requestId)
{
String msgStr="";
msgStr += MESSAGETYPE_FLAG+":"+CONFIRMATION_FLAG;
msgStr += ","+ENTITYID_FLAG+":"+entityId;
msgStr += ","+NUMBOUNCES_FLAG+":"+0;
msgStr += ","+REQUESTID_FLAG+":"+requestId;
return "{"+msgStr+"}";
}
public static String CreateRegisterMessage(long entityId,int requestsSent)
{
String msgStr="";
msgStr += MESSAGETYPE_FLAG+":"+REGISTER_FLAG;
msgStr += ","+REQUESTID_FLAG+":"+entityId+10;
msgStr += ","+NUMBOUNCES_FLAG+":"+0;
msgStr += ","+ENTITYID_FLAG+":"+entityId;
;
msgStr="{"+msgStr+"}";
return msgStr;
}
public static String BuildPingEntityMessage(MyDetectedEntityInfo info,long entityid,int requestsSent)
{
String msgStr="";
var hitpos=info.HitPosition;
msgStr += MESSAGETYPE_FLAG+":"+PINGENTITY_FLAG;
msgStr += ","+TARGETID_FLAG+":"+info.EntityId;
msgStr += ","+ENTITYID_FLAG+":"+entityid;
msgStr += ","+TARGETRADIUS_FLAG+":"+(int)Math.Abs((info.BoundingBox.Min-info.BoundingBox.Max).Length());
msgStr += ","+REQUESTID_FLAG+":"+info.EntityId+requestsSent;
msgStr += ","+TYPE_FLAG+":"+info.Type.ToString();
msgStr += ","+VELOCITY_FLAG+":"+VectorToString(info.Velocity);
msgStr += ","+LOCATION_FLAG+":"+VectorToString(info.Position);
msgStr += ","+RELATIONSHIP_FLAG+":"+info.Relationship;
msgStr += ","+NUMBOUNCES_FLAG+":"+0;
msgStr += ","+NAME_FLAG+":"+info.Name;
if (hitpos.HasValue)
msgStr += ","+ATTACKPOINT_FLAG+":"+VectorToString(hitpos.Value);
msgStr="{"+msgStr+"}";
return msgStr;
}
}
public class DockVector
{
public Vector3D Location;
public bool Reached=false;
public DockVector(Vector3D pos)
{
Location=pos;
}
}
public class TaskInfo
{
private int maxResultsKept=20;
List<TaskResult> PreviousResults=new List<TaskResult>();
public Action CallMethod;
public TaskInfo(Action a)
{
CallMethod=a;
}
public void AddResult(TaskResult tr)
{
PreviousResults.Add(tr);
while (PreviousResults.Count() > maxResultsKept)
PreviousResults.RemoveAt(0);
}
public double GetAverageCallCount()
{
return PreviousResults.Max(a => a.percentCapCall);
}
public double GetAverageCallDepth()
{
return PreviousResults.Max(a => a.percentCapDepth);
}
public double GetTrueAverageExecutionTime()
{
return PreviousResults.Max(a => a.trueRuntme);
}
}
public class TaskResult
{
public double trueRuntme;
public double percentCapDepth;
public double percentCapCall;
public TaskResult(double cc,double cd)
{
percentCapDepth=cd;
percentCapCall=cc;
}
}